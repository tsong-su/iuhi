<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–</title>
<style>
  :root{
    --bg:#f9f6ef;
    --title-color:#222;
    --new-color:#c0392b;
    --old-color:#555;
    --label-font: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:var(--label-font); color:var(--title-color)}
  .page {
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
    padding:12px;
    box-sizing:border-box;
  }
  h1{
    margin:8px 0 0 0;
    font-size:1.25rem;
    text-align:center;
  }
  .subtitle{
    margin:0; font-size:0.95rem; color:#666; text-align:center;
  }

  /* map area: portrait-first */
  .map-stage{
    width:100%;
    max-width:900px;
    height: calc(100vh - 160px);
    max-height:1200px;
    background:transparent;
    border-radius:10px;
    overflow:hidden;
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
  }

  /* svg container scales responsively */
  #svgWrap{
    width:92%;
    height:100%;
  }
  #svgWrap svg { width:100%; height:100%; display:block; }

  /* labels placed inside svg use same classes */
  .map-label-new {
    font-size:12px;
    font-weight:700;
    fill:var(--new-color);
    text-anchor:middle;
    pointer-events:none;
  }
  .map-label-old {
    font-size:12px;
    font-weight:400;
    fill:var(--old-color);
    text-anchor:middle;
    pointer-events:none;
  }

  /* popup */
  .popup{
    position:absolute;
    display:none;
    min-width:220px;
    max-width:320px;
    background:white;
    border-radius:10px;
    box-shadow:0 8px 28px rgba(0,0,0,0.18);
    border:1px solid rgba(0,0,0,0.08);
    padding:10px 12px;
    z-index:50;
  }
  .popup h3{margin:0 0 6px 0; font-size:1rem}
  .popup .muted{color:#666; font-size:0.9rem}
  .popup .audioRow{display:flex; gap:10px; margin-top:8px}
  .audioBtn{background:#ddd;border-radius:8px;padding:8px 10px;border:none;color:#666;cursor:not-allowed}

  /* legend / note */
  .note{margin-top:6px;color:#555;font-size:0.90rem;text-align:center}

  @media (max-width:640px){
    h1{font-size:1.05rem}
    .map-stage{height: calc(100vh - 130px);}
    .map-label-new, .map-label-old{font-size:13px}
    .popup{min-width:72%; left:14% !important; right:auto}
  }
</style>
</head>
<body>
  <div class="page">
    <h1>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–</h1>
    <div class="subtitle">ğŸ“± å»ºè­°ç›´å¼è§€çœ‹æ•ˆæœæœ€ä½³</div>

    <div class="map-stage" aria-hidden="false">
      <div id="svgWrap">è¼‰å…¥åœ°åœ–â€¦</div>

      <!-- popup -->
      <div id="popup" class="popup" role="dialog" aria-live="polite">
        <h3 id="popupNew">æ–°åœ°å</h3>
        <div id="popupOld" class="muted">èˆŠåœ°å</div>
        <div class="audioRow">
          <button class="audioBtn" id="btnNew">ğŸ”ˆ æ–°åœ°åï¼ˆé ç•™ï¼‰</button>
          <button class="audioBtn" id="btnOld">ğŸ”ˆ èˆŠåœ°åï¼ˆé ç•™ï¼‰</button>
        </div>
      </div>
    </div>

    <div class="note">â€» æœ¬åœ–ç‚ºåŸºç¤åœ°åœ–ï¼Œå¾ŒçºŒæœƒæ‹†æˆ 4 å›éŠæˆ²ï¼ˆæœ¬ç‰ˆæœ¬å·²ä»¥å››å¤§è‰²ç³»å€åˆ†ç¾¤çµ„ä¸¦é¡¯ç¤ºæ–°ï¼èˆŠåœ°åï¼‰</div>
  </div>

<script>
/* ================= Configuration ================= */
/* Use the raw GitHub svg URL (raw.githubusercontent) */
const RAW_SVG_URL = 'https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg';

/* grouping (no 'å€' suffix) */
const groups = {
  "center": ["æ¥ æ¢“","å·¦ç‡Ÿ","é¼“å±±","ä¸‰æ°‘","é¹½åŸ•","å‰é‡‘","æ–°èˆˆ","è‹“é›…","æ——æ´¥","å‰é®","å°æ¸¯"],
  "east":   ["å¤§æ¨¹","å¤§å¯®","æ—åœ’","å¤§ç¤¾","ä»æ­¦","é³¥æ¾","é³³å±±"],
  "north":  ["èŒ„è£","æ°¸å®‰","å½Œé™€","æ¢“å®˜","æ¹–å…§","è·¯ç«¹","å²¡å±±","æ©‹é ­","é˜¿è“®","ç”°å¯®","ç‡•å·¢"],
  "mount":  ["å…§é–€","æ——å±±","æ‰æ—","ç¾æ¿ƒ","ç”²ä»™","å…­é¾œ","é‚£ç‘ªå¤","æ¡ƒæº","èŒ‚æ—"]
};

/* single color per group (will vary slightly via algorithm) */
const groupColor = {
  center: '#f4a261', /* æš–ç´…ç³» */
  east:   '#a29bfe', /* ç´«ç³» */
  north:  '#b8e994', /* é»ƒç¶ ç³» */
  mount:  '#48c9b0'  /* è—ç¶ ç³» */
};

/* new/old mappings and å°ç¾… (already provided earlier) */
const placeData = {
  "æ¥ æ¢“": { new_tl: "LÃ¢m-tsÃº", old_tl: "LÃ¢m-Ã¡-khenn" },
  "å·¦ç‡Ÿ": { new_tl: "TsÃ³-iÃ¢nn", old_tl: "Hing-liÃ´ng-lÃ­" },
  "é¼“å±±": { new_tl: "KÃ³o-san", old_tl: "TÃ¡nn-kÃ³o-san" },
  "ä¸‰æ°‘": { new_tl: "Sam-bÃ®n", old_tl: "Sann-tÃ¨-tshÃ¹" },
  "é¹½åŸ•": { new_tl: "IÃ¢m-tiann", old_tl: "IÃ¢m-tiann-poo" },
  "å‰é‡‘": { new_tl: "TsiÃ¢n-kim", old_tl: "TsiÃ¢n-khim" },
  "æ–°èˆˆ": { new_tl: "Sin-hing", old_tl: "TÄi-kÃ¡ng-poo" },
  "è‹“é›…": { new_tl: "LÃ®ng-ngÃ¡", old_tl: "LÃ®ng-Ã¡-liÃ¢u" },
  "æ——æ´¥": { new_tl: "KÃ®-tin", old_tl: "KÃ®-Äu" },
  "å‰é®": { new_tl: "TsiÃ¢n-tÃ¬n", old_tl: "TsiÃ¢n-tÃ¬n" },
  "å°æ¸¯": { new_tl: "SiÃ³-kÃ¡ng", old_tl: "KÃ¡ng-Ã¡ kÃ®nn" },
  "å¤§æ¨¹": { new_tl: "TuÄ-tshiÅ«", old_tl: "TuÄ-tshiÅ«-kha" },
  "å¤§å¯®": { new_tl: "TuÄ-liÃ¢u", old_tl: "TuÄ-liÃ¢u" },
  "æ—åœ’": { new_tl: "LÃ®m-hnÌ‚g", old_tl: "TÃ­ng-nÃ¢-Ã¡-pinn" },
  "å¤§ç¤¾": { new_tl: "TuÄ-siÄ", old_tl: "Sam-nÃ¡i-tuÃ¢nn" },
  "ä»æ­¦": { new_tl: "JÃ®n-bÃº", old_tl: "JÃ®n-bÃº-tÃ¬n" },
  "é³¥æ¾": { new_tl: "TsiÃ¡u-tshÃ¬ng", old_tl: "TsiÃ¡u-tshÃ¬ng-kha" },
  "é³³å±±": { new_tl: "HÅng-suann", old_tl: "Ä’-pi-thÃ¢u" },
  "èŒ„è£": { new_tl: "Ka-tiÄnn", old_tl: "Ka-tang-tiÄnn-Ã¡" },
  "æ°¸å®‰": { new_tl: "Ãng-an", old_tl: "Oo-tshiÅ«-nÃ¢" },
  "å½Œé™€": { new_tl: "MÃ®-tÃ´", old_tl: "BÃ®-lÃ´-kÃ¡ng" },
  "æ¢“å®˜": { new_tl: "TsÃº-kuann", old_tl: "TsÃº-kuann" },
  "æ¹–å…§": { new_tl: "Ã”o-lÄi", old_tl: "TuÄ-Ã´o" },
  "è·¯ç«¹": { new_tl: "LÅo-tik", old_tl: "PuÃ nn-lÅo-tik" },
  "å²¡å±±": { new_tl: "Kong-san", old_tl: "A-kong-tiÃ m" },
  "æ©‹é ­": { new_tl: "KiÃ´-thÃ¢u", old_tl: "KiÃ´-Ã¡-thÃ¢u" },
  "é˜¿è“®": { new_tl: "A-lian", old_tl: "lian-siÄ" },
  "ç”°å¯®": { new_tl: "TshÃ¢n-liÃ¢u", old_tl: "TshÃ¢n-liÃ¢u" },
  "ç‡•å·¢": { new_tl: "IÃ n-tsÃ¢u", old_tl: "UÄn-tsÃ¢u-iÅ«" },
  "å…§é–€": { new_tl: "LÄi-bÃ»n", old_tl: "LÃ´-hÃ n-lÄi-bÃ»n" },
  "æ——å±±": { new_tl: "KÃ®-san", old_tl: "Han-tsÃ®-liÃ¢u" },
  "æ‰æ—": { new_tl: "Sam-nÃ¢", old_tl: "LÃ¢m-tsÃº-sian" },
  "ç¾æ¿ƒ": { new_tl: "Bi-long", old_tl: "BÃ®-long" },
  "ç”²ä»™": { new_tl: "Kah-sian", old_tl: "A-lÃ­-kuan" },
  "å…­é¾œ": { new_tl: "LaÌk-ku", old_tl: "LaÌk-ku-lÃ­-siÄ" },
  "é‚£ç‘ªå¤": { new_tl: "Na-mÃ¡-siah", old_tl: "Mangacun" },
  "æ¡ƒæº": { new_tl: "ThÃ´-guÃ¢n", old_tl: "Ngani" },
  "èŒ‚æ—": { new_tl: "BÅo-lÃ®m", old_tl: "TÅ«n-Ã¡" }
};

/* helper to detect group by name */
function findGroup(name) {
  for (const k in groups) {
    if (groups[k].includes(name)) return k;
  }
  return null;
}

/* ================= Load & render SVG ================= */
const wrap = document.getElementById('svgWrap');
const popup = document.getElementById('popup');
const popupNew = document.getElementById('popupNew');
const popupOld = document.getElementById('popupOld');

async function init() {
  try {
    const res = await fetch(RAW_SVG_URL);
    if (!res.ok) throw new Error('SVG å–å¾—å¤±æ•—: ' + res.status);
    const svgText = await res.text();
    // inline svg
    wrap.innerHTML = svgText;
    const svg = wrap.querySelector('svg');
    if(!svg) throw new Error('SVG æª”æ¡ˆæ ¼å¼ä¸æ­£ç¢ºï¼ˆæ‰¾ä¸åˆ° <svg>ï¼‰');

    // remove any large black frame if exists (try remove path with id or class containing "frame")
    const possibleFrames = svg.querySelectorAll('path,rect');
    possibleFrames.forEach(p=>{
      const id = p.id || '';
      const cls = p.getAttribute('class') || '';
      // heuristic: if very large bbox covering most canvas and black stroke, hide it
      try{
        const bb = p.getBBox();
        const area = bb.width * bb.height;
        const svgArea = svg.viewBox.baseVal.width * svg.viewBox.baseVal.height || (svg.clientWidth * svg.clientHeight);
        if(area > 0 && svgArea && (area / svgArea) > 0.5) {
          // hide if stroke is dark and thick
          const stroke = (p.getAttribute('stroke') || '').toLowerCase();
          const sw = parseFloat(p.getAttribute('stroke-width') || '0');
          if((stroke === '#000' || stroke === 'black' || stroke.includes('black')) && sw >= 2) {
            p.style.display = 'none';
          }
        }
      }catch(e){}
    });

    // Find area elements: prefer elements with title
    const candidates = Array.from(svg.querySelectorAll('path,polygon,rect,g'));
    const areas = candidates.filter(el=>{
      const t = el.querySelector && el.querySelector('title');
      return (t && t.textContent && t.textContent.trim()) || (el.id && el.id.trim());
    });

    const targetEls = areas.length ? areas : Array.from(svg.querySelectorAll('path'));

    // For each target element: extract name, apply color, bind events, compute label pos
    const svgNS = "http://www.w3.org/2000/svg";
    // create a <g> for labels on top
    let labelGroup = svg.querySelector('#__labelGroup');
    if(!labelGroup){
      labelGroup = document.createElementNS(svgNS,'g');
      labelGroup.setAttribute('id','__labelGroup');
      svg.appendChild(labelGroup);
    }

    targetEls.forEach((el, idx) => {
      // get title text: may include "å°æ¸¯å€ Xiaogang District"
      let titleText = '';
      try {
        const tnode = el.querySelector && el.querySelector('title');
        titleText = (tnode && tnode.textContent) ? tnode.textContent.trim() : '';
      } catch(e){ titleText = ''; }
      // name: first sequence of chinese characters, remove trailing 'å€'
      let name = '';
      if(titleText){
        const m = titleText.match(/^[\u4e00-\u9fff]+/);
        if(m && m[0]) name = m[0].replace(/å€$/,'');
      }
      if(!name) {
        name = (el.id || '').replace(/^_+/,'') || ('å€å¡Š'+(idx+1));
      }
      el.dataset.name = name;

      // color by group
      const g = findGroup(name);
      const baseColor = g ? groupColor[g] : '#e0e0e0';
      // set fill only if not set or white
      const curFill = (el.getAttribute('fill')||'').toLowerCase();
      if(!curFill || curFill === 'none' || curFill === '#ffffff' || curFill === 'white') {
        el.setAttribute('fill', baseColor);
      } else {
        // keep existing
      }
      el.setAttribute('stroke','#ffffff');
      el.setAttribute('stroke-width','1');

      // add class for hover style
      el.classList.add('map-area');

      // compute centroid / bbox for label
      let bbox;
      try {
        bbox = el.getBBox();
      } catch(e) {
        bbox = null;
      }
      if(bbox && bbox.width > 0 && bbox.height > 0){
        // create group with two text lines: new (top) and old (bottom)
        const tx = bbox.x + bbox.width/2;
        const ty = bbox.y + bbox.height/2;
        // create a group element for label
        const gLabel = document.createElementNS(svgNS,'g');
        gLabel.setAttribute('data-for', name);
        gLabel.setAttribute('transform', `translate(${tx},${ty})`);
        // new name
        const tNew = document.createElementNS(svgNS,'text');
        tNew.setAttribute('class','map-label-new');
        tNew.setAttribute('dy','-4'); // slightly up
        tNew.textContent = name;
        // old name (from placeData)
        const old = placeData[name] ? placeData[name].old_tl : '';
        const tOld = document.createElementNS(svgNS,'text');
        tOld.setAttribute('class','map-label-old');
        tOld.setAttribute('dy','14'); // below
        tOld.textContent = old ? old : '';
        // append
        gLabel.appendChild(tNew);
        gLabel.appendChild(tOld);
        // prevent pointer events on labels
        gLabel.style.pointerEvents = 'none';
        labelGroup.appendChild(gLabel);
      }

      // interaction: click to popup
      const onClick = (ev) => {
        ev.stopPropagation();
        showPopup(el, ev);
      };
      el.addEventListener('click', onClick);
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); onClick(e); });
      // hover effect
      el.addEventListener('mouseenter', ()=>{ el.style.filter = 'brightness(1.08)'; });
      el.addEventListener('mouseleave', ()=>{ el.style.filter = ''; });
    });

    // reposition labels on resize (recompute using getBBox to account for viewBox scaling)
    window.addEventListener('resize', () => {
      // recompute transforms: for each label group, find its referenced area and recompute bbox center
      Array.from(svg.querySelectorAll('#__labelGroup > g')).forEach(gLabel => {
        const name = gLabel.getAttribute('data-for');
        const area = targetEls.find(a=>a.dataset.name===name);
        if(area){
          try{
            const bb = area.getBBox();
            const tx = bb.x + bb.width/2;
            const ty = bb.y + bb.height/2;
            gLabel.setAttribute('transform', `translate(${tx},${ty})`);
          }catch(e){}
        }
      });
    });

    // click outside to hide popup
    document.addEventListener('click', (e)=>{
      if(popup.style.display !== 'none'){
        popup.style.display = 'none';
      }
    });

  } catch(err) {
    wrap.innerHTML = '<div style="padding:18px;color:#900;background:#fff;border-radius:8px">è¼‰å…¥åœ°åœ–å¤±æ•—ï¼š'+err.message+'</div>';
    console.error(err);
  }
}

/* show popup near event (client coords -> map-stage coords) */
function showPopup(areaEl, ev){
  // fill content
  const name = areaEl.dataset.name || '';
  const pd = placeData[name] || {};
  document.getElementById('popupNew').textContent = name + (pd.new_tl ? ('ã€€('+pd.new_tl+')') : '');
  document.getElementById('popupOld').textContent = (pd.old_tl ? pd.old_tl : 'ï¼ˆç„¡èˆŠåè³‡æ–™ï¼‰');

  // position popup relative to map-stage
  const stage = document.querySelector('.map-stage');
  const rect = stage.getBoundingClientRect();
  // compute local x,y
  let clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (rect.left + rect.width/2);
  let clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || (rect.top + rect.height/2);

  let px = clientX - rect.left + 8;
  let py = clientY - rect.top + 8;

  const popupEl = document.getElementById('popup');
  // adjust to prevent overflow
  const popupW = 300, popupH = 160;
  if(px + popupW > rect.width) px = Math.max(8, clientX - rect.left - popupW - 8);
  if(py + popupH > rect.height) py = Math.max(8, clientY - rect.top - popupH - 8);

  popupEl.style.left = px + 'px';
  popupEl.style.top = py + 'px';
  popupEl.style.display = 'block';
}

/* start */
init();
</script>
</body>
</html>
