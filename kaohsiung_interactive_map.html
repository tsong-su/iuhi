<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–ï¼ˆä¿®æ­£ç‰ˆï¼‰</title>
<style>
  :root{
    --bg:#f9f6ef;
    --title-color:#222;
    --new-color:#c0392b;
    --old-color:#555;
    --label-font: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:var(--label-font); color:var(--title-color)}
  .page {display:flex; flex-direction:column; align-items:center; gap:6px; padding:12px; box-sizing:border-box;}
  h1{margin:8px 0 0 0; font-size:1.25rem; text-align:center;}
  .subtitle{margin:0; font-size:0.95rem; color:#666; text-align:center;}

  .map-stage{width:100%; max-width:960px; height: calc(100vh - 170px); max-height:1300px; background:transparent; border-radius:10px; overflow:hidden; position:relative;}
  #svgWrap{width:100%; height:100%;}

  /* svg label styles (these classes applied to created <text> elements) */
  .label-new { font: 700 12px / 1 "Noto Sans TC", sans-serif; fill: var(--new-color); text-anchor:middle; pointer-events:none; }
  .label-old { font: 400 12px / 1 "Noto Sans TC", sans-serif; fill: var(--old-color); text-anchor:middle; pointer-events:none; }

  .popup{position:absolute; display:none; min-width:220px; max-width:320px; background:white; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,0.18); border:1px solid rgba(0,0,0,0.08); padding:10px 12px; z-index:50;}
  .popup h3{margin:0 0 6px 0; font-size:1rem}
  .popup .muted{color:#666; font-size:0.9rem}
  .audioRow{display:flex; gap:10px; margin-top:8px}
  .audioBtn{background:#ddd;border-radius:8px;padding:8px 10px;border:none;color:#666;cursor:not-allowed}

  .note{margin-top:6px;color:#555;font-size:0.90rem;text-align:center}
  @media (max-width:640px){
    h1{font-size:1.05rem}
    .map-stage{height: calc(100vh - 120px);}
    .label-new, .label-old { font-size:13px; }
    .popup{min-width:72%; left:14% !important; right:auto}
  }
</style>
</head>
<body>
  <div class="page">
    <h1>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–</h1>
    <div class="subtitle">ğŸ“± å»ºè­°ç›´å¼è§€çœ‹æ•ˆæœæœ€ä½³</div>

    <div class="map-stage" id="stage">
      <div id="svgWrap">è¼‰å…¥åœ°åœ–â€¦</div>
      <div id="popup" class="popup" role="dialog" aria-live="polite">
        <h3 id="popupNew">æ–°åœ°å</h3>
        <div id="popupOld" class="muted">èˆŠåœ°å</div>
        <div class="audioRow">
          <button class="audioBtn" id="btnNew">ğŸ”ˆ æ–°åœ°åï¼ˆé ç•™ï¼‰</button>
          <button class="audioBtn" id="btnOld">ğŸ”ˆ èˆŠåœ°åï¼ˆé ç•™ï¼‰</button>
        </div>
      </div>
    </div>

    <div class="note">â€» æœ¬åœ–ç‚ºåŸºç¤åœ°åœ–ï¼Œå¾ŒçºŒæœƒæ‹†æˆ 4 å›éŠæˆ²ï¼ˆæœ¬ç‰ˆæœ¬å·²è‡ªå‹•æŠŠ 38 å€æ¨™è¨˜æ–°ï¼èˆŠåœ°åä¸¦ä»¥å››ç¾¤è‰²ç³»ä¸Šè‰²ï¼‰ã€‚</div>
  </div>

<script>
/* ========== Config ========== */
const RAW_SVG_URL = 'https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg';

/* grouping arrays (no "å€") */
const groups = {
  center: ["æ¥ æ¢“","å·¦ç‡Ÿ","é¼“å±±","ä¸‰æ°‘","é¹½åŸ•","å‰é‡‘","æ–°èˆˆ","è‹“é›…","æ——æ´¥","å‰é®","å°æ¸¯"],
  east:   ["å¤§æ¨¹","å¤§å¯®","æ—åœ’","å¤§ç¤¾","ä»æ­¦","é³¥æ¾","é³³å±±"],
  north:  ["èŒ„è£","æ°¸å®‰","å½Œé™€","æ¢“å®˜","æ¹–å…§","è·¯ç«¹","å²¡å±±","æ©‹é ­","é˜¿è“®","ç”°å¯®","ç‡•å·¢"],
  mount:  ["å…§é–€","æ——å±±","æ‰æ—","ç¾æ¿ƒ","ç”²ä»™","å…­é¾œ","é‚£ç‘ªå¤","æ¡ƒæº","èŒ‚æ—"]
};

const groupColor = { center:'#f4a261', east:'#a29bfe', north:'#b8e994', mount:'#48c9b0' };

/* placeData now contains both Chinese old name (old_ch) and è‡ºç¾… (old_tl) */
const placeData = {
  "æ¥ æ¢“": { new_ch:"æ¥ æ¢“", new_tl:"LÃ¢m-tsÃº", old_ch:"æ¥ ä»”å‘", old_tl:"LÃ¢m-Ã¡-khenn" },
  "å·¦ç‡Ÿ": { new_ch:"å·¦ç‡Ÿ", new_tl:"TsÃ³-iÃ¢nn", old_ch:"èˆˆéš†é‡Œ", old_tl:"Hing-liÃ´ng-lÃ­" },
  "é¼“å±±": { new_ch:"é¼“å±±", new_tl:"KÃ³o-san", old_ch:"æ‰“ç‹—å±±", old_tl:"TÃ¡nn-kÃ³o-san" },
  "ä¸‰æ°‘": { new_ch:"ä¸‰æ°‘", new_tl:"Sam-bÃ®n", old_ch:"ä¸‰å¡Šå", old_tl:"Sann-tÃ¨-tshÃ¹" },
  "é¹½åŸ•": { new_ch:"é¹½åŸ•", new_tl:"IÃ¢m-tiann", old_ch:"é¹½åŸ•åŸ”", old_tl:"IÃ¢m-tiann-poo" },
  "å‰é‡‘": { new_ch:"å‰é‡‘", new_tl:"TsiÃ¢n-kim", old_ch:"å‰è¡¿", old_tl:"TsiÃ¢n-khim" },
  "æ–°èˆˆ": { new_ch:"æ–°èˆˆ", new_tl:"Sin-hing", old_ch:"é€®æ¸¯åŸ”", old_tl:"TÄi-kÃ¡ng-poo" },
  "è‹“é›…": { new_ch:"è‹“é›…", new_tl:"LÃ®ng-ngÃ¡", old_ch:"ç¬­ä»”å¯®", old_tl:"LÃ®ng-Ã¡-liÃ¢u" },
  "æ——æ´¥": { new_ch:"æ——æ´¥", new_tl:"KÃ®-tin", old_ch:"æ——å¾Œ", old_tl:"KÃ®-Äu" },
  "å‰é®": { new_ch:"å‰é®", new_tl:"TsiÃ¢n-tÃ¬n", old_ch:"å‰é®", old_tl:"TsiÃ¢n-tÃ¬n" },
  "å°æ¸¯": { new_ch:"å°æ¸¯", new_tl:"SiÃ³-kÃ¡ng", old_ch:"æ¸¯ä»”å¢˜", old_tl:"KÃ¡ng-Ã¡ kÃ®nn" },

  "å¤§æ¨¹": { new_ch:"å¤§æ¨¹", new_tl:"TuÄ-tshiÅ«", old_ch:"å¤§æ¨¹è·¤", old_tl:"TuÄ-tshiÅ«-kha" },
  "å¤§å¯®": { new_ch:"å¤§å¯®", new_tl:"TuÄ-liÃ¢u", old_ch:"å¤§è—”", old_tl:"TuÄ-liÃ¢u" },
  "æ—åœ’": { new_ch:"æ—åœ’", new_tl:"LÃ®m-hnÌ‚g", old_ch:"é ‚æ—ä»”é‚Š", old_tl:"TÃ­ng-nÃ¢-Ã¡-pinn" },
  "å¤§ç¤¾": { new_ch:"å¤§ç¤¾", new_tl:"TuÄ-siÄ", old_ch:"ä¸‰å¥¶å£‡", old_tl:"Sam-nÃ¡i-tuÃ¢nn" },
  "ä»æ­¦": { new_ch:"ä»æ­¦", new_tl:"JÃ®n-bÃº", old_ch:"ä»æ­¦é®", old_tl:"JÃ®n-bÃº-tÃ¬n" },
  "é³¥æ¾": { new_ch:"é³¥æ¾", new_tl:"TsiÃ¡u-tshÃ¬ng", old_ch:"é³¥æ¾è·¤", old_tl:"TsiÃ¡u-tshÃ¬ng-kha" },
  "é³³å±±": { new_ch:"é³³å±±", new_tl:"HÅng-suann", old_ch:"ä¸‹åŸ¤é ­", old_tl:"Ä’-pi-thÃ¢u" },

  "èŒ„è£": { new_ch:"èŒ„è£", new_tl:"Ka-tiÄnn", old_ch:"èŒ„è‹³è£ä»”", old_tl:"Ka-tang-tiÄnn-Ã¡" },
  "æ°¸å®‰": { new_ch:"æ°¸å®‰", new_tl:"Ãng-an", old_ch:"çƒæ¨¹æ—", old_tl:"Oo-tshiÅ«-nÃ¢" },
  "å½Œé™€": { new_ch:"å½Œé™€", new_tl:"MÃ®-tÃ´", old_ch:"å½Œé™€æ¸¯", old_tl:"BÃ®-lÃ´-kÃ¡ng" },
  "æ¢“å®˜": { new_ch:"æ¢“å®˜", new_tl:"TsÃº-kuann", old_ch:"æ¢“å®˜", old_tl:"TsÃº-kuann" },
  "æ¹–å…§": { new_ch:"æ¹–å…§", new_tl:"Ã”o-lÄi", old_ch:"å¤§æ¹–", old_tl:"TuÄ-Ã´o" },
  "è·¯ç«¹": { new_ch:"è·¯ç«¹", new_tl:"LÅo-tik", old_ch:"åŠè·¯ç«¹", old_tl:"PuÃ nn-lÅo-tik" },
  "å²¡å±±": { new_ch:"å²¡å±±", new_tl:"Kong-san", old_ch:"é˜¿å…¬åº—", old_tl:"A-kong-tiÃ m" },
  "æ©‹é ­": { new_ch:"æ©‹é ­", new_tl:"KiÃ´-thÃ¢u", old_ch:"æ©‹ä»”é ­", old_tl:"KiÃ´-Ã¡-thÃ¢u" },
  "é˜¿è“®": { new_ch:"é˜¿è“®", new_tl:"A-lian", old_ch:"é˜¿å—¹ç¤¾", old_tl:"A-lian-siÄ" },
  "ç”°å¯®": { new_ch:"ç”°å¯®", new_tl:"TshÃ¢n-liÃ¢u", old_ch:"ç”°è—”", old_tl:"TshÃ¢n-liÃ¢u" },
  "ç‡•å·¢": { new_ch:"ç‡•å·¢", new_tl:"IÃ n-tsÃ¢u", old_ch:"æ´å‰¿å³", old_tl:"UÄn-tsÃ¢u-iÅ«" },

  "å…§é–€": { new_ch:"å…§é–€", new_tl:"LÄi-bÃ»n", old_ch:"ç¾…æ¼¢å…§é–€", old_tl:"LÃ´-hÃ n-lÄi-bÃ»n" },
  "æ——å±±": { new_ch:"æ——å±±", new_tl:"KÃ®-san", old_ch:"è•ƒè–¯è—”", old_tl:"Han-tsÃ®-liÃ¢u" },
  "æ‰æ—": { new_ch:"æ‰æ—", new_tl:"Sam-nÃ¢", old_ch:"æ¥ æ¢“ä»™", old_tl:"LÃ¢m-tsÃº-sian" },
  "ç¾æ¿ƒ": { new_ch:"ç¾æ¿ƒ", new_tl:"Bi-long", old_ch:"ç€°æ¿ƒ", old_tl:"BÃ®-long" },
  "ç”²ä»™": { new_ch:"ç”²ä»™", new_tl:"Kah-sian", old_ch:"é˜¿é‡Œé—œ", old_tl:"A-lÃ­-kuan" },
  "å…­é¾œ": { new_ch:"å…­é¾œ", new_tl:"LaÌk-ku", old_ch:"å…­é¾œé‡Œç¤¾", old_tl:"LaÌk-ku-lÃ­-siÄ" },
  "é‚£ç‘ªå¤": { new_ch:"é‚£ç‘ªå¤", new_tl:"Na-mÃ¡-siah", old_ch:"èšŠå­åª", old_tl:"Mangacun" },
  "æ¡ƒæº": { new_ch:"æ¡ƒæº", new_tl:"ThÃ´-guÃ¢n", old_ch:"é›…çˆ¾", old_tl:"Ngani" },
  "èŒ‚æ—": { new_ch:"èŒ‚æ—", new_tl:"BÅo-lÃ®m", old_ch:"å±¯ä»”", old_tl:"TÅ«n-Ã¡" }
};

/* helper: find group */
function findGroup(name){
  for(const k in groups) if(groups[k].includes(name)) return k;
  return null;
}

/* ========== render inline SVG and labels ========== */
const wrap = document.getElementById('svgWrap');
const popup = document.getElementById('popup');
const popupNew = document.getElementById('popupNew');
const popupOld = document.getElementById('popupOld');
const stage = document.getElementById('stage');

async function init(){
  try{
    const res = await fetch(RAW_SVG_URL);
    if(!res.ok) throw new Error('SVG load failed: ' + res.status);
    const svgText = await res.text();

    // Inline the SVG
    wrap.innerHTML = svgText;
    const svg = wrap.querySelector('svg');
    if(!svg) throw new Error('<svg> not found in file');

    // ensure preserveAspectRatio to keep entire map visible
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');

    // attempt to hide any large black frames that cover map
    Array.from(svg.querySelectorAll('path, rect')).forEach(el=>{
      try{
        const bb = el.getBBox();
        const svgBB = svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width ? (svg.viewBox.baseVal.width * svg.viewBox.baseVal.height) : (svg.clientWidth*svg.clientHeight);
        if(bb && svgBB){
          const area = bb.width*bb.height;
          if(area / svgBB > 0.5){
            const stroke = (el.getAttribute('stroke')||'').toLowerCase();
            const sw = parseFloat(el.getAttribute('stroke-width')||0);
            if((stroke.includes('black') || stroke === '#000' || sw > 3)){
              el.style.display = 'none';
            }
          }
        }
      }catch(e){}
    });

    // gather candidate areas (prefer elements with <title>)
    const candidates = Array.from(svg.querySelectorAll('path, polygon, rect, g'));
    const areas = candidates.filter(el=>{
      const t = el.querySelector && el.querySelector('title');
      return (t && t.textContent && t.textContent.trim()) || (el.id && el.id.trim());
    });
    const targetEls = areas.length ? areas : Array.from(svg.querySelectorAll('path'));

    // create label group on top
    const svgNS = "http://www.w3.org/2000/svg";
    let labelGroup = svg.querySelector('#__labels');
    if(!labelGroup){
      labelGroup = document.createElementNS(svgNS,'g');
      labelGroup.setAttribute('id','__labels');
      svg.appendChild(labelGroup);
    }

    // for each area, compute central point in SVG coordinates and create two-line label
    targetEls.forEach(el=>{
      // get title Chinese name if exists
      let titleText = '';
      try{ const t = el.querySelector && el.querySelector('title'); if(t) titleText = t.textContent.trim(); }catch(e){}
      let name = '';
      if(titleText){
        const m = titleText.match(/^[\u4e00-\u9fff]+/);
        if(m && m[0]) name = m[0].replace(/å€$/,'');
      }
      if(!name) name = (el.id||'').replace(/^_+/,'') || 'æœªçŸ¥';

      el.dataset.name = name;

      // set fill color by group if empty
      const curFill = (el.getAttribute('fill')||'').toLowerCase();
      const grp = findGroup(name);
      const base = grp ? groupColor[grp] : '#e0e0e0';
      if(!curFill || curFill === 'none' || curFill === '#ffffff' || curFill === 'white'){
        el.setAttribute('fill', base);
      }
      el.setAttribute('stroke','#ffffff');
      el.setAttribute('stroke-width','1');

      // compute bbox center in local svg coords, but account for transforms:
      let cx=0, cy=0;
      try{
        const bb = el.getBBox();
        cx = bb.x + bb.width/2;
        cy = bb.y + bb.height/2;
        // transform point by element's CTM to svg's user coords
        let pt = svg.createSVGPoint();
        pt.x = cx; pt.y = cy;
        const m = el.getCTM();
        if(m){
          const transformed = pt.matrixTransform(m);
          cx = transformed.x; cy = transformed.y;
        } else {
          // if no CTM, keep as is
        }
      }catch(e){
        // fallback: place at center of svg viewbox
        try{
          const vb = svg.viewBox.baseVal;
          cx = vb.x + vb.width/2; cy = vb.y + vb.height/2;
        }catch(err){}
      }

      // create group for two-line label
      const gLabel = document.createElementNS(svgNS,'g');
      gLabel.setAttribute('data-for', name);
      gLabel.setAttribute('transform', `translate(${cx},${cy})`);
      gLabel.style.pointerEvents = 'none';

      // text: new (ch)
      const tNew = document.createElementNS(svgNS,'text');
      tNew.setAttribute('class','label-new');
      tNew.setAttribute('y', -6);
      tNew.textContent = placeData[name] ? placeData[name].new_ch : name;

      // text: old (ch + è‡ºç¾… in parentheses)
      const tOld = document.createElementNS(svgNS,'text');
      tOld.setAttribute('class','label-old');
      tOld.setAttribute('y', 12);
      const oldCh = placeData[name] ? placeData[name].old_ch : '';
      const oldTl = placeData[name] ? placeData[name].old_tl : '';
      tOld.textContent = oldCh ? (oldCh + (oldTl ? ('ã€€('+oldTl+')') : '')) : (oldTl || '');

      labelGroup.appendChild(gLabel);
      gLabel.appendChild(tNew);
      gLabel.appendChild(tOld);

      // interaction: click -> popup
      const onClick = (ev) => { ev.stopPropagation(); showPopup(el, ev); };
      el.addEventListener('click', onClick);
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); onClick(e); });
      el.addEventListener('mouseenter', ()=> el.style.filter = 'brightness(1.08)');
      el.addEventListener('mouseleave', ()=> el.style.filter = '');
    });

    // Recompute labels on window resize (recalculate transformed centers)
    window.addEventListener('resize', ()=> {
      Array.from(svg.querySelectorAll('#__labels > g')).forEach(gLabel=>{
        const name = gLabel.getAttribute('data-for');
        const area = targetEls.find(a=>a.dataset.name === name);
        if(area){
          try{
            const bb = area.getBBox();
            let cx = bb.x + bb.width/2;
            let cy = bb.y + bb.height/2;
            let pt = svg.createSVGPoint(); pt.x = cx; pt.y = cy;
            const m = area.getCTM();
            if(m){ const t = pt.matrixTransform(m); cx = t.x; cy = t.y; }
            gLabel.setAttribute('transform', `translate(${cx},${cy})`);
          }catch(e){}
        }
      });
    });

    // click outside to hide popup
    document.addEventListener('click', ()=> { popup.style.display = 'none'; });

  }catch(err){
    wrap.innerHTML = '<div style="padding:18px;color:#900;background:#fff;border-radius:8px">è¼‰å…¥åœ°åœ–å¤±æ•—ï¼š'+err.message+'</div>';
    console.error(err);
  }
}

/* popup positioning using stage rect */
function showPopup(areaEl, ev){
  const name = areaEl.dataset.name || '';
  const pd = placeData[name] || {};
  document.getElementById('popupNew').textContent = (pd.new_ch || name) + (pd.new_tl ? ('ã€€('+pd.new_tl+')') : '');
  document.getElementById('popupOld').textContent = (pd.old_ch ? pd.old_ch : '') + (pd.old_tl ? ('ã€€('+pd.old_tl+')') : '');

  const stageRect = document.getElementById('stage').getBoundingClientRect();
  let clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (stageRect.left + stageRect.width/2);
  let clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || (stageRect.top + stageRect.height/2);

  const px = clientX - stageRect.left + 8;
  const py = clientY - stageRect.top + 8;
  const popupEl = document.getElementById('popup');
  // basic overflow handling
  const pw = Math.min(320, stageRect.width - 16);
  const ph = 160;
  let left = px; let top = py;
  if(left + pw > stageRect.width) left = Math.max(8, px - pw - 8);
  if(top + ph > stageRect.height) top = Math.max(8, py - ph - 8);

  popupEl.style.left = left + 'px';
  popupEl.style.top = top + 'px';
  popupEl.style.display = 'block';
}

init();
</script>
</body>
</html>
