<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>高雄市38區新舊地名互動地圖（修正版2）</title>
<style>
  :root{
    --bg:#f9f6ef;
    --title-color:#222;
    --new-color:#c0392b;
    --old-color:#555;
    --label-font: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:var(--label-font); color:var(--title-color)}
  .page{display:flex; flex-direction:column; align-items:center; gap:6px; padding:12px; box-sizing:border-box;}
  h1{margin:8px 0 0 0; font-size:1.25rem; text-align:center;}
  .subtitle{margin:0; font-size:0.95rem; color:#666; text-align:center;}
  .map-stage{width:100%; max-width:980px; height: calc(100vh - 170px); max-height:1200px; background:transparent; border-radius:10px; overflow:hidden; position:relative;}
  #svgObject{width:100%; height:100%; border:0; display:block;}
  /* overlay labels (HTML elements) */
  .label {
    position:absolute;
    transform:translate(-50%,-50%);
    pointer-events:none;
    text-align:center;
    line-height:1.05;
    white-space:nowrap;
  }
  .label .new { font-weight:700; color:var(--new-color); font-size:13px; }
  .label .old { font-weight:400; color:var(--old-color); font-size:13px; margin-top:2px; }
  .popup{position:absolute; display:none; min-width:220px; max-width:320px; background:white; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,0.18); border:1px solid rgba(0,0,0,0.08); padding:10px 12px; z-index:60;}
  .popup h3{margin:0 0 6px 0; font-size:1rem}
  .muted{color:#666; font-size:0.95rem}
  .audioRow{display:flex; gap:10px; margin-top:8px}
  .audioBtn{background:#ddd;border-radius:8px;padding:8px 10px;border:none;color:#666;cursor:not-allowed}
  .note{margin-top:6px;color:#555;font-size:0.90rem;text-align:center}
  @media (max-width:640px){
    .map-stage{height: calc(100vh - 140px);}
    .label .new, .label .old { font-size:14px; }
    .popup{min-width:72%; left:14% !important; right:auto}
  }
</style>
</head>
<body>
  <div class="page">
    <h1>高雄市38區新舊地名互動地圖</h1>
    <div class="subtitle">📱 建議直式觀看效果最佳</div>

    <div class="map-stage" id="stage">
      <!-- embed svg via object for stable scaling -->
      <object id="svgObject" type="image/svg+xml" data="https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg"></object>

      <!-- HTML overlay container for labels -->
      <div id="labelsLayer" style="position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; z-index:50;"></div>

      <!-- popup -->
      <div id="popup" class="popup" role="dialog" aria-live="polite">
        <h3 id="popupNew">新地名</h3>
        <div id="popupOld" class="muted">舊地名</div>
        <div class="audioRow">
          <button class="audioBtn" id="btnNew">🔈 新地名（預留）</button>
          <button class="audioBtn" id="btnOld">🔈 舊地名（預留）</button>
        </div>
      </div>
    </div>

    <div class="note">※ 本圖為基礎地圖，後續會拆成 4 回遊戲（目前已依四群上色並在圖上顯示新／舊中文）。</div>
  </div>

<script>
/* ========== Config ========== */
const RAW_SVG_URL = 'https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg';

/* group definitions (no "區") */
const groups = {
  center: ["楠梓","左營","鼓山","三民","鹽埕","前金","新興","苓雅","旗津","前鎮","小港"],
  east:   ["大樹","大寮","林園","大社","仁武","鳥松","鳳山"],
  north:  ["茄萣","永安","彌陀","梓官","湖內","路竹","岡山","橋頭","阿蓮","田寮","燕巢"],
  mount:  ["內門","旗山","杉林","美濃","甲仙","六龜","那瑪夏","桃源","茂林"]
};

const groupColor = { center:'#f4a261', east:'#a29bfe', north:'#b8e994', mount:'#48c9b0' };

/* placeData: show only Chinese (new_ch / old_ch) on map labels */
const placeData = {
  "楠梓": { new_ch:"楠梓", old_ch:"楠仔坑" },
  "左營": { new_ch:"左營", old_ch:"興隆里" },
  "鼓山": { new_ch:"鼓山", old_ch:"打狗山" },
  "三民": { new_ch:"三民", old_ch:"三塊厝" },
  "鹽埕": { new_ch:"鹽埕", old_ch:"鹽埕埔" },
  "前金": { new_ch:"前金", old_ch:"前衿" },
  "新興": { new_ch:"新興", old_ch:"逮港埔" },
  "苓雅": { new_ch:"苓雅", old_ch:"笭仔寮" },
  "旗津": { new_ch:"旗津", old_ch:"旗後" },
  "前鎮": { new_ch:"前鎮", old_ch:"前鎮" },
  "小港": { new_ch:"小港", old_ch:"港仔墘" },

  "大樹": { new_ch:"大樹", old_ch:"大樹跤" },
  "大寮": { new_ch:"大寮", old_ch:"大藔" },
  "林園": { new_ch:"林園", old_ch:"頂林仔邊" },
  "大社": { new_ch:"大社", old_ch:"三奶壇" },
  "仁武": { new_ch:"仁武", old_ch:"仁武鎮" },
  "鳥松": { new_ch:"鳥松", old_ch:"鳥松跤" },
  "鳳山": { new_ch:"鳳山", old_ch:"下埤頭" },

  "茄萣": { new_ch:"茄萣", old_ch:"茄苳萣仔" },
  "永安": { new_ch:"永安", old_ch:"烏樹林" },
  "彌陀": { new_ch:"彌陀", old_ch:"彌陀港" },
  "梓官": { new_ch:"梓官", old_ch:"梓官" },
  "湖內": { new_ch:"湖內", old_ch:"大湖" },
  "路竹": { new_ch:"路竹", old_ch:"半路竹" },
  "岡山": { new_ch:"岡山", old_ch:"阿公店" },
  "橋頭": { new_ch:"橋頭", old_ch:"橋仔頭" },
  "阿蓮": { new_ch:"阿蓮", old_ch:"阿嗹社" },
  "田寮": { new_ch:"田寮", old_ch:"田藔" },
  "燕巢": { new_ch:"燕巢", old_ch:"援剿右" },

  "內門": { new_ch:"內門", old_ch:"羅漢內門" },
  "旗山": { new_ch:"旗山", old_ch:"蕃薯藔" },
  "杉林": { new_ch:"杉林", old_ch:"楠梓仙" },
  "美濃": { new_ch:"美濃", old_ch:"瀰濃" },
  "甲仙": { new_ch:"甲仙", old_ch:"阿里關" },
  "六龜": { new_ch:"六龜", old_ch:"六龜里社" },
  "那瑪夏": { new_ch:"那瑪夏", old_ch:"蚊子只" },
  "桃源": { new_ch:"桃源", old_ch:"雅爾" },
  "茂林": { new_ch:"茂林", old_ch:"屯仔" }
};

/* helper */
function findGroup(name){
  for(const k in groups) if(groups[k].includes(name)) return k;
  return null;
}

/* main: when object loads, create labels overlay based on element bounding rect */
const obj = document.getElementById('svgObject');
const labelsLayer = document.getElementById('labelsLayer');
const popup = document.getElementById('popup');
const popupNew = document.getElementById('popupNew');
const popupOld = document.getElementById('popupOld');
let lastAreas = [];

obj.addEventListener('load', ()=> {
  try {
    const svgDoc = obj.contentDocument;
    const svg = svgDoc.querySelector('svg');
    if(!svg) { console.error('SVG not found inside object'); return; }

    // attempt to hide a giant black frame element (heuristic)
    try{
      Array.from(svg.querySelectorAll('path,rect')).forEach(el=>{
        try{
          const bb = el.getBBox();
          const svgBB = svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width ? (svg.viewBox.baseVal.width * svg.viewBox.baseVal.height) : (svg.clientWidth*svg.clientHeight);
          if(bb && svgBB){
            const area = bb.width*bb.height;
            if(area / svgBB > 0.5){
              const stroke = (el.getAttribute('stroke')||'').toLowerCase();
              const sw = parseFloat(el.getAttribute('stroke-width')||0);
              if((stroke.includes('black') || stroke === '#000' || sw > 3)){
                el.style.display = 'none';
              }
            }
          }
        }catch(e){}
      });
    }catch(e){}

    // find area elements (prefer having title)
    const candidates = Array.from(svg.querySelectorAll('path,polygon,rect,g'));
    const areas = candidates.filter(el=>{
      const t = el.querySelector && el.querySelector('title');
      return (t && t.textContent && t.textContent.trim()) || (el.id && el.id.trim());
    });
    const targetEls = areas.length ? areas : Array.from(svg.querySelectorAll('path'));
    lastAreas = targetEls;

    // color each element by group
    targetEls.forEach(el=>{
      // read title chinese name
      let titleText = '';
      try { const t = el.querySelector && el.querySelector('title'); if(t) titleText = t.textContent.trim(); } catch(e){}
      let name = '';
      if(titleText) {
        const m = titleText.match(/^[\u4e00-\u9fff]+/);
        if(m && m[0]) name = m[0].replace(/區$/,'');
      }
      if(!name) name = (el.id||'').replace(/^_+/,'') || '';
      el.dataset.name = name;

      // color
      const g = findGroup(name);
      if(g){
        const base = groupColor[g];
        // apply only if no fill or white
        const curFill = (el.getAttribute('fill')||'').toLowerCase();
        if(!curFill || curFill === 'none' || curFill === '#ffffff' || curFill === 'white'){
          el.setAttribute('fill', base);
        }
      }
      // stroke
      el.setAttribute('stroke','#ffffff');
      el.setAttribute('stroke-width','1');

      // click handler: show popup
      const onClick = (ev) => {
        ev.stopPropagation();
        showPopup(name, ev);
      };
      el.addEventListener('click', onClick);
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); onClick(e); });
    });

    // create labels overlay by computing each element's screen bbox and centering an HTML div
    function placeLabels(){
      labelsLayer.innerHTML = '';
      const stageRect = document.getElementById('stage').getBoundingClientRect();
      targetEls.forEach(el=>{
        try{
          const bbox = el.getBoundingClientRect(); // screen coords
          if(bbox.width < 6 && bbox.height < 6) return; // skip tiny
          const cx = bbox.left + bbox.width/2;
          const cy = bbox.top + bbox.height/2;
          // convert to labelsLayer coordinates
          const lx = cx - stageRect.left;
          const ly = cy - stageRect.top;

          const name = el.dataset.name || '';
          const pd = placeData[name] || {};
          // create label div
          const div = document.createElement('div');
          div.className = 'label';
          div.style.left = lx + 'px';
          div.style.top = ly + 'px';
          div.innerHTML = `<div class="new">${pd.new_ch || name}</div><div class="old">${pd.old_ch || ''}</div>`;
          labelsLayer.appendChild(div);
        }catch(e){}
      });
    }

    // initial placement after small delay (allow rendering)
    setTimeout(placeLabels, 300);

    // reposition on resize & scroll & object resize
    window.addEventListener('resize', ()=> setTimeout(placeLabels,200));
    window.addEventListener('scroll', ()=> setTimeout(placeLabels,200));
    // also periodically reposition in case object scales later
    let repositionTimer = setInterval(placeLabels, 1200);
    // stop reposition after some seconds to avoid infinite timer
    setTimeout(()=> clearInterval(repositionTimer), 8000);

    // clicking outside closes popup
    document.addEventListener('click', ()=> { document.getElementById('popup').style.display = 'none'; });

  } catch(err){
    console.error('object load error', err);
  }
});

/* popup handler */
function showPopup(name, ev){
  const pd = placeData[name] || {};
  document.getElementById('popupNew').textContent = (pd.new_ch || name);
  document.getElementById('popupOld').textContent = (pd.old_ch || '');
  const stage = document.getElementById('stage');
  const rect = stage.getBoundingClientRect();
  let clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (rect.left + rect.width/2);
  let clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || (rect.top + rect.height/2);
  let left = clientX - rect.left + 8;
  let top = clientY - rect.top + 8;
  const popupEl = document.getElementById('popup');
  const pw = Math.min(320, rect.width - 16), ph = 160;
  if(left + pw > rect.width) left = Math.max(8, clientX - rect.left - pw - 8);
  if(top + ph > rect.height) top = Math.max(8, clientY - rect.top - ph - 8);
  popupEl.style.left = left + 'px';
  popupEl.style.top = top + 'px';
  popupEl.style.display = 'block';
}
</script>
</body>
</html>
