<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>高雄市38區新舊地名互動地圖</title>
<style>
  :root{
    --bg:#f9f6ef;
    --title-color:#222;
    --new-color:#c0392b;
    --old-color:#555;
    --label-font: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:var(--label-font); color:var(--title-color)}
  .page {
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
    padding:12px;
    box-sizing:border-box;
  }
  h1{
    margin:8px 0 0 0;
    font-size:1.25rem;
    text-align:center;
  }
  .subtitle{
    margin:0; font-size:0.95rem; color:#666; text-align:center;
  }

  /* map area: portrait-first */
  .map-stage{
    width:100%;
    max-width:900px;
    height: calc(100vh - 160px);
    max-height:1200px;
    background:transparent;
    border-radius:10px;
    overflow:hidden;
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
  }

  /* svg container scales responsively */
  #svgWrap{
    width:92%;
    height:100%;
  }
  #svgWrap svg { width:100%; height:100%; display:block; }

  /* labels placed inside svg use same classes */
  .map-label-new {
    font-size:12px;
    font-weight:700;
    fill:var(--new-color);
    text-anchor:middle;
    pointer-events:none;
  }
  .map-label-old {
    font-size:12px;
    font-weight:400;
    fill:var(--old-color);
    text-anchor:middle;
    pointer-events:none;
  }

  /* popup */
  .popup{
    position:absolute;
    display:none;
    min-width:220px;
    max-width:320px;
    background:white;
    border-radius:10px;
    box-shadow:0 8px 28px rgba(0,0,0,0.18);
    border:1px solid rgba(0,0,0,0.08);
    padding:10px 12px;
    z-index:50;
  }
  .popup h3{margin:0 0 6px 0; font-size:1rem}
  .popup .muted{color:#666; font-size:0.9rem}
  .popup .audioRow{display:flex; gap:10px; margin-top:8px}
  .audioBtn{background:#ddd;border-radius:8px;padding:8px 10px;border:none;color:#666;cursor:not-allowed}

  /* legend / note */
  .note{margin-top:6px;color:#555;font-size:0.90rem;text-align:center}

  @media (max-width:640px){
    h1{font-size:1.05rem}
    .map-stage{height: calc(100vh - 130px);}
    .map-label-new, .map-label-old{font-size:13px}
    .popup{min-width:72%; left:14% !important; right:auto}
  }
</style>
</head>
<body>
  <div class="page">
    <h1>高雄市38區新舊地名互動地圖</h1>
    <div class="subtitle">📱 建議直式觀看效果最佳</div>

    <div class="map-stage" aria-hidden="false">
      <div id="svgWrap">載入地圖…</div>

      <!-- popup -->
      <div id="popup" class="popup" role="dialog" aria-live="polite">
        <h3 id="popupNew">新地名</h3>
        <div id="popupOld" class="muted">舊地名</div>
        <div class="audioRow">
          <button class="audioBtn" id="btnNew">🔈 新地名（預留）</button>
          <button class="audioBtn" id="btnOld">🔈 舊地名（預留）</button>
        </div>
      </div>
    </div>

    <div class="note">※ 本圖為基礎地圖，後續會拆成 4 回遊戲（本版本已以四大色系區分群組並顯示新／舊地名）</div>
  </div>

<script>
/* ================= Configuration ================= */
/* Use the raw GitHub svg URL (raw.githubusercontent) */
const RAW_SVG_URL = 'https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg';

/* grouping (no '區' suffix) */
const groups = {
  "center": ["楠梓","左營","鼓山","三民","鹽埕","前金","新興","苓雅","旗津","前鎮","小港"],
  "east":   ["大樹","大寮","林園","大社","仁武","鳥松","鳳山"],
  "north":  ["茄萣","永安","彌陀","梓官","湖內","路竹","岡山","橋頭","阿蓮","田寮","燕巢"],
  "mount":  ["內門","旗山","杉林","美濃","甲仙","六龜","那瑪夏","桃源","茂林"]
};

/* single color per group (will vary slightly via algorithm) */
const groupColor = {
  center: '#f4a261', /* 暖紅系 */
  east:   '#a29bfe', /* 紫系 */
  north:  '#b8e994', /* 黃綠系 */
  mount:  '#48c9b0'  /* 藍綠系 */
};

/* new/old mappings and 台羅 (already provided earlier) */
const placeData = {
  "楠梓": { new_tl: "Lâm-tsú", old_tl: "Lâm-á-khenn" },
  "左營": { new_tl: "Tsó-iânn", old_tl: "Hing-liông-lí" },
  "鼓山": { new_tl: "Kóo-san", old_tl: "Tánn-kóo-san" },
  "三民": { new_tl: "Sam-bîn", old_tl: "Sann-tè-tshù" },
  "鹽埕": { new_tl: "Iâm-tiann", old_tl: "Iâm-tiann-poo" },
  "前金": { new_tl: "Tsiân-kim", old_tl: "Tsiân-khim" },
  "新興": { new_tl: "Sin-hing", old_tl: "Tāi-káng-poo" },
  "苓雅": { new_tl: "Lîng-ngá", old_tl: "Lîng-á-liâu" },
  "旗津": { new_tl: "Kî-tin", old_tl: "Kî-āu" },
  "前鎮": { new_tl: "Tsiân-tìn", old_tl: "Tsiân-tìn" },
  "小港": { new_tl: "Sió-káng", old_tl: "Káng-á kînn" },
  "大樹": { new_tl: "Tuā-tshiū", old_tl: "Tuā-tshiū-kha" },
  "大寮": { new_tl: "Tuā-liâu", old_tl: "Tuā-liâu" },
  "林園": { new_tl: "Lîm-hn̂g", old_tl: "Tíng-nâ-á-pinn" },
  "大社": { new_tl: "Tuā-siā", old_tl: "Sam-nái-tuânn" },
  "仁武": { new_tl: "Jîn-bú", old_tl: "Jîn-bú-tìn" },
  "鳥松": { new_tl: "Tsiáu-tshìng", old_tl: "Tsiáu-tshìng-kha" },
  "鳳山": { new_tl: "Hōng-suann", old_tl: "Ē-pi-thâu" },
  "茄萣": { new_tl: "Ka-tiānn", old_tl: "Ka-tang-tiānn-á" },
  "永安": { new_tl: "Íng-an", old_tl: "Oo-tshiū-nâ" },
  "彌陀": { new_tl: "Mî-tô", old_tl: "Bî-lô-káng" },
  "梓官": { new_tl: "Tsú-kuann", old_tl: "Tsú-kuann" },
  "湖內": { new_tl: "Ôo-lāi", old_tl: "Tuā-ôo" },
  "路竹": { new_tl: "Lōo-tik", old_tl: "Puànn-lōo-tik" },
  "岡山": { new_tl: "Kong-san", old_tl: "A-kong-tiàm" },
  "橋頭": { new_tl: "Kiô-thâu", old_tl: "Kiô-á-thâu" },
  "阿蓮": { new_tl: "A-lian", old_tl: "lian-siā" },
  "田寮": { new_tl: "Tshân-liâu", old_tl: "Tshân-liâu" },
  "燕巢": { new_tl: "Iàn-tsâu", old_tl: "Uān-tsâu-iū" },
  "內門": { new_tl: "Lāi-bûn", old_tl: "Lô-hàn-lāi-bûn" },
  "旗山": { new_tl: "Kî-san", old_tl: "Han-tsî-liâu" },
  "杉林": { new_tl: "Sam-nâ", old_tl: "Lâm-tsú-sian" },
  "美濃": { new_tl: "Bi-long", old_tl: "Bî-long" },
  "甲仙": { new_tl: "Kah-sian", old_tl: "A-lí-kuan" },
  "六龜": { new_tl: "La̍k-ku", old_tl: "La̍k-ku-lí-siā" },
  "那瑪夏": { new_tl: "Na-má-siah", old_tl: "Mangacun" },
  "桃源": { new_tl: "Thô-guân", old_tl: "Ngani" },
  "茂林": { new_tl: "Bōo-lîm", old_tl: "Tūn-á" }
};

/* helper to detect group by name */
function findGroup(name) {
  for (const k in groups) {
    if (groups[k].includes(name)) return k;
  }
  return null;
}

/* ================= Load & render SVG ================= */
const wrap = document.getElementById('svgWrap');
const popup = document.getElementById('popup');
const popupNew = document.getElementById('popupNew');
const popupOld = document.getElementById('popupOld');

async function init() {
  try {
    const res = await fetch(RAW_SVG_URL);
    if (!res.ok) throw new Error('SVG 取得失敗: ' + res.status);
    const svgText = await res.text();
    // inline svg
    wrap.innerHTML = svgText;
    const svg = wrap.querySelector('svg');
    if(!svg) throw new Error('SVG 檔案格式不正確（找不到 <svg>）');

    // remove any large black frame if exists (try remove path with id or class containing "frame")
    const possibleFrames = svg.querySelectorAll('path,rect');
    possibleFrames.forEach(p=>{
      const id = p.id || '';
      const cls = p.getAttribute('class') || '';
      // heuristic: if very large bbox covering most canvas and black stroke, hide it
      try{
        const bb = p.getBBox();
        const area = bb.width * bb.height;
        const svgArea = svg.viewBox.baseVal.width * svg.viewBox.baseVal.height || (svg.clientWidth * svg.clientHeight);
        if(area > 0 && svgArea && (area / svgArea) > 0.5) {
          // hide if stroke is dark and thick
          const stroke = (p.getAttribute('stroke') || '').toLowerCase();
          const sw = parseFloat(p.getAttribute('stroke-width') || '0');
          if((stroke === '#000' || stroke === 'black' || stroke.includes('black')) && sw >= 2) {
            p.style.display = 'none';
          }
        }
      }catch(e){}
    });

    // Find area elements: prefer elements with title
    const candidates = Array.from(svg.querySelectorAll('path,polygon,rect,g'));
    const areas = candidates.filter(el=>{
      const t = el.querySelector && el.querySelector('title');
      return (t && t.textContent && t.textContent.trim()) || (el.id && el.id.trim());
    });

    const targetEls = areas.length ? areas : Array.from(svg.querySelectorAll('path'));

    // For each target element: extract name, apply color, bind events, compute label pos
    const svgNS = "http://www.w3.org/2000/svg";
    // create a <g> for labels on top
    let labelGroup = svg.querySelector('#__labelGroup');
    if(!labelGroup){
      labelGroup = document.createElementNS(svgNS,'g');
      labelGroup.setAttribute('id','__labelGroup');
      svg.appendChild(labelGroup);
    }

    targetEls.forEach((el, idx) => {
      // get title text: may include "小港區 Xiaogang District"
      let titleText = '';
      try {
        const tnode = el.querySelector && el.querySelector('title');
        titleText = (tnode && tnode.textContent) ? tnode.textContent.trim() : '';
      } catch(e){ titleText = ''; }
      // name: first sequence of chinese characters, remove trailing '區'
      let name = '';
      if(titleText){
        const m = titleText.match(/^[\u4e00-\u9fff]+/);
        if(m && m[0]) name = m[0].replace(/區$/,'');
      }
      if(!name) {
        name = (el.id || '').replace(/^_+/,'') || ('區塊'+(idx+1));
      }
      el.dataset.name = name;

      // color by group
      const g = findGroup(name);
      const baseColor = g ? groupColor[g] : '#e0e0e0';
      // set fill only if not set or white
      const curFill = (el.getAttribute('fill')||'').toLowerCase();
      if(!curFill || curFill === 'none' || curFill === '#ffffff' || curFill === 'white') {
        el.setAttribute('fill', baseColor);
      } else {
        // keep existing
      }
      el.setAttribute('stroke','#ffffff');
      el.setAttribute('stroke-width','1');

      // add class for hover style
      el.classList.add('map-area');

      // compute centroid / bbox for label
      let bbox;
      try {
        bbox = el.getBBox();
      } catch(e) {
        bbox = null;
      }
      if(bbox && bbox.width > 0 && bbox.height > 0){
        // create group with two text lines: new (top) and old (bottom)
        const tx = bbox.x + bbox.width/2;
        const ty = bbox.y + bbox.height/2;
        // create a group element for label
        const gLabel = document.createElementNS(svgNS,'g');
        gLabel.setAttribute('data-for', name);
        gLabel.setAttribute('transform', `translate(${tx},${ty})`);
        // new name
        const tNew = document.createElementNS(svgNS,'text');
        tNew.setAttribute('class','map-label-new');
        tNew.setAttribute('dy','-4'); // slightly up
        tNew.textContent = name;
        // old name (from placeData)
        const old = placeData[name] ? placeData[name].old_tl : '';
        const tOld = document.createElementNS(svgNS,'text');
        tOld.setAttribute('class','map-label-old');
        tOld.setAttribute('dy','14'); // below
        tOld.textContent = old ? old : '';
        // append
        gLabel.appendChild(tNew);
        gLabel.appendChild(tOld);
        // prevent pointer events on labels
        gLabel.style.pointerEvents = 'none';
        labelGroup.appendChild(gLabel);
      }

      // interaction: click to popup
      const onClick = (ev) => {
        ev.stopPropagation();
        showPopup(el, ev);
      };
      el.addEventListener('click', onClick);
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); onClick(e); });
      // hover effect
      el.addEventListener('mouseenter', ()=>{ el.style.filter = 'brightness(1.08)'; });
      el.addEventListener('mouseleave', ()=>{ el.style.filter = ''; });
    });

    // reposition labels on resize (recompute using getBBox to account for viewBox scaling)
    window.addEventListener('resize', () => {
      // recompute transforms: for each label group, find its referenced area and recompute bbox center
      Array.from(svg.querySelectorAll('#__labelGroup > g')).forEach(gLabel => {
        const name = gLabel.getAttribute('data-for');
        const area = targetEls.find(a=>a.dataset.name===name);
        if(area){
          try{
            const bb = area.getBBox();
            const tx = bb.x + bb.width/2;
            const ty = bb.y + bb.height/2;
            gLabel.setAttribute('transform', `translate(${tx},${ty})`);
          }catch(e){}
        }
      });
    });

    // click outside to hide popup
    document.addEventListener('click', (e)=>{
      if(popup.style.display !== 'none'){
        popup.style.display = 'none';
      }
    });

  } catch(err) {
    wrap.innerHTML = '<div style="padding:18px;color:#900;background:#fff;border-radius:8px">載入地圖失敗：'+err.message+'</div>';
    console.error(err);
  }
}

/* show popup near event (client coords -> map-stage coords) */
function showPopup(areaEl, ev){
  // fill content
  const name = areaEl.dataset.name || '';
  const pd = placeData[name] || {};
  document.getElementById('popupNew').textContent = name + (pd.new_tl ? ('　('+pd.new_tl+')') : '');
  document.getElementById('popupOld').textContent = (pd.old_tl ? pd.old_tl : '（無舊名資料）');

  // position popup relative to map-stage
  const stage = document.querySelector('.map-stage');
  const rect = stage.getBoundingClientRect();
  // compute local x,y
  let clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (rect.left + rect.width/2);
  let clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || (rect.top + rect.height/2);

  let px = clientX - rect.left + 8;
  let py = clientY - rect.top + 8;

  const popupEl = document.getElementById('popup');
  // adjust to prevent overflow
  const popupW = 300, popupH = 160;
  if(px + popupW > rect.width) px = Math.max(8, clientX - rect.left - popupW - 8);
  if(py + popupH > rect.height) py = Math.max(8, clientY - rect.top - popupH - 8);

  popupEl.style.left = px + 'px';
  popupEl.style.top = py + 'px';
  popupEl.style.display = 'block';
}

/* start */
init();
</script>
</body>
</html>
