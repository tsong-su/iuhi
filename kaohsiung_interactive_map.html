<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–ï¼ˆä¿®æ­£ç‰ˆ2ï¼‰</title>
<style>
  :root{
    --bg:#f9f6ef;
    --title-color:#222;
    --new-color:#c0392b;
    --old-color:#555;
    --label-font: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:var(--label-font); color:var(--title-color)}
  .page{display:flex; flex-direction:column; align-items:center; gap:6px; padding:12px; box-sizing:border-box;}
  h1{margin:8px 0 0 0; font-size:1.25rem; text-align:center;}
  .subtitle{margin:0; font-size:0.95rem; color:#666; text-align:center;}
  .map-stage{width:100%; max-width:980px; height: calc(100vh - 170px); max-height:1200px; background:transparent; border-radius:10px; overflow:hidden; position:relative;}
  #svgObject{width:100%; height:100%; border:0; display:block;}
  /* overlay labels (HTML elements) */
  .label {
    position:absolute;
    transform:translate(-50%,-50%);
    pointer-events:none;
    text-align:center;
    line-height:1.05;
    white-space:nowrap;
  }
  .label .new { font-weight:700; color:var(--new-color); font-size:13px; }
  .label .old { font-weight:400; color:var(--old-color); font-size:13px; margin-top:2px; }
  .popup{position:absolute; display:none; min-width:220px; max-width:320px; background:white; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,0.18); border:1px solid rgba(0,0,0,0.08); padding:10px 12px; z-index:60;}
  .popup h3{margin:0 0 6px 0; font-size:1rem}
  .muted{color:#666; font-size:0.95rem}
  .audioRow{display:flex; gap:10px; margin-top:8px}
  .audioBtn{background:#ddd;border-radius:8px;padding:8px 10px;border:none;color:#666;cursor:not-allowed}
  .note{margin-top:6px;color:#555;font-size:0.90rem;text-align:center}
  @media (max-width:640px){
    .map-stage{height: calc(100vh - 140px);}
    .label .new, .label .old { font-size:14px; }
    .popup{min-width:72%; left:14% !important; right:auto}
  }
</style>
</head>
<body>
  <div class="page">
    <h1>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–</h1>
    <div class="subtitle">ğŸ“± å»ºè­°ç›´å¼è§€çœ‹æ•ˆæœæœ€ä½³</div>

    <div class="map-stage" id="stage">
      <!-- embed svg via object for stable scaling -->
      <object id="svgObject" type="image/svg+xml" data="https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg"></object>

      <!-- HTML overlay container for labels -->
      <div id="labelsLayer" style="position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; z-index:50;"></div>

      <!-- popup -->
      <div id="popup" class="popup" role="dialog" aria-live="polite">
        <h3 id="popupNew">æ–°åœ°å</h3>
        <div id="popupOld" class="muted">èˆŠåœ°å</div>
        <div class="audioRow">
          <button class="audioBtn" id="btnNew">ğŸ”ˆ æ–°åœ°åï¼ˆé ç•™ï¼‰</button>
          <button class="audioBtn" id="btnOld">ğŸ”ˆ èˆŠåœ°åï¼ˆé ç•™ï¼‰</button>
        </div>
      </div>
    </div>

    <div class="note">â€» æœ¬åœ–ç‚ºåŸºç¤åœ°åœ–ï¼Œå¾ŒçºŒæœƒæ‹†æˆ 4 å›éŠæˆ²ï¼ˆç›®å‰å·²ä¾å››ç¾¤ä¸Šè‰²ä¸¦åœ¨åœ–ä¸Šé¡¯ç¤ºæ–°ï¼èˆŠä¸­æ–‡ï¼‰ã€‚</div>
  </div>

<script>
/* ========== Config ========== */
const RAW_SVG_URL = 'https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg';

/* group definitions (no "å€") */
const groups = {
  center: ["æ¥ æ¢“","å·¦ç‡Ÿ","é¼“å±±","ä¸‰æ°‘","é¹½åŸ•","å‰é‡‘","æ–°èˆˆ","è‹“é›…","æ——æ´¥","å‰é®","å°æ¸¯"],
  east:   ["å¤§æ¨¹","å¤§å¯®","æ—åœ’","å¤§ç¤¾","ä»æ­¦","é³¥æ¾","é³³å±±"],
  north:  ["èŒ„è£","æ°¸å®‰","å½Œé™€","æ¢“å®˜","æ¹–å…§","è·¯ç«¹","å²¡å±±","æ©‹é ­","é˜¿è“®","ç”°å¯®","ç‡•å·¢"],
  mount:  ["å…§é–€","æ——å±±","æ‰æ—","ç¾æ¿ƒ","ç”²ä»™","å…­é¾œ","é‚£ç‘ªå¤","æ¡ƒæº","èŒ‚æ—"]
};

const groupColor = { center:'#f4a261', east:'#a29bfe', north:'#b8e994', mount:'#48c9b0' };

/* placeData: show only Chinese (new_ch / old_ch) on map labels */
const placeData = {
  "æ¥ æ¢“": { new_ch:"æ¥ æ¢“", old_ch:"æ¥ ä»”å‘" },
  "å·¦ç‡Ÿ": { new_ch:"å·¦ç‡Ÿ", old_ch:"èˆˆéš†é‡Œ" },
  "é¼“å±±": { new_ch:"é¼“å±±", old_ch:"æ‰“ç‹—å±±" },
  "ä¸‰æ°‘": { new_ch:"ä¸‰æ°‘", old_ch:"ä¸‰å¡Šå" },
  "é¹½åŸ•": { new_ch:"é¹½åŸ•", old_ch:"é¹½åŸ•åŸ”" },
  "å‰é‡‘": { new_ch:"å‰é‡‘", old_ch:"å‰è¡¿" },
  "æ–°èˆˆ": { new_ch:"æ–°èˆˆ", old_ch:"é€®æ¸¯åŸ”" },
  "è‹“é›…": { new_ch:"è‹“é›…", old_ch:"ç¬­ä»”å¯®" },
  "æ——æ´¥": { new_ch:"æ——æ´¥", old_ch:"æ——å¾Œ" },
  "å‰é®": { new_ch:"å‰é®", old_ch:"å‰é®" },
  "å°æ¸¯": { new_ch:"å°æ¸¯", old_ch:"æ¸¯ä»”å¢˜" },

  "å¤§æ¨¹": { new_ch:"å¤§æ¨¹", old_ch:"å¤§æ¨¹è·¤" },
  "å¤§å¯®": { new_ch:"å¤§å¯®", old_ch:"å¤§è—”" },
  "æ—åœ’": { new_ch:"æ—åœ’", old_ch:"é ‚æ—ä»”é‚Š" },
  "å¤§ç¤¾": { new_ch:"å¤§ç¤¾", old_ch:"ä¸‰å¥¶å£‡" },
  "ä»æ­¦": { new_ch:"ä»æ­¦", old_ch:"ä»æ­¦é®" },
  "é³¥æ¾": { new_ch:"é³¥æ¾", old_ch:"é³¥æ¾è·¤" },
  "é³³å±±": { new_ch:"é³³å±±", old_ch:"ä¸‹åŸ¤é ­" },

  "èŒ„è£": { new_ch:"èŒ„è£", old_ch:"èŒ„è‹³è£ä»”" },
  "æ°¸å®‰": { new_ch:"æ°¸å®‰", old_ch:"çƒæ¨¹æ—" },
  "å½Œé™€": { new_ch:"å½Œé™€", old_ch:"å½Œé™€æ¸¯" },
  "æ¢“å®˜": { new_ch:"æ¢“å®˜", old_ch:"æ¢“å®˜" },
  "æ¹–å…§": { new_ch:"æ¹–å…§", old_ch:"å¤§æ¹–" },
  "è·¯ç«¹": { new_ch:"è·¯ç«¹", old_ch:"åŠè·¯ç«¹" },
  "å²¡å±±": { new_ch:"å²¡å±±", old_ch:"é˜¿å…¬åº—" },
  "æ©‹é ­": { new_ch:"æ©‹é ­", old_ch:"æ©‹ä»”é ­" },
  "é˜¿è“®": { new_ch:"é˜¿è“®", old_ch:"é˜¿å—¹ç¤¾" },
  "ç”°å¯®": { new_ch:"ç”°å¯®", old_ch:"ç”°è—”" },
  "ç‡•å·¢": { new_ch:"ç‡•å·¢", old_ch:"æ´å‰¿å³" },

  "å…§é–€": { new_ch:"å…§é–€", old_ch:"ç¾…æ¼¢å…§é–€" },
  "æ——å±±": { new_ch:"æ——å±±", old_ch:"è•ƒè–¯è—”" },
  "æ‰æ—": { new_ch:"æ‰æ—", old_ch:"æ¥ æ¢“ä»™" },
  "ç¾æ¿ƒ": { new_ch:"ç¾æ¿ƒ", old_ch:"ç€°æ¿ƒ" },
  "ç”²ä»™": { new_ch:"ç”²ä»™", old_ch:"é˜¿é‡Œé—œ" },
  "å…­é¾œ": { new_ch:"å…­é¾œ", old_ch:"å…­é¾œé‡Œç¤¾" },
  "é‚£ç‘ªå¤": { new_ch:"é‚£ç‘ªå¤", old_ch:"èšŠå­åª" },
  "æ¡ƒæº": { new_ch:"æ¡ƒæº", old_ch:"é›…çˆ¾" },
  "èŒ‚æ—": { new_ch:"èŒ‚æ—", old_ch:"å±¯ä»”" }
};

/* helper */
function findGroup(name){
  for(const k in groups) if(groups[k].includes(name)) return k;
  return null;
}

/* main: when object loads, create labels overlay based on element bounding rect */
const obj = document.getElementById('svgObject');
const labelsLayer = document.getElementById('labelsLayer');
const popup = document.getElementById('popup');
const popupNew = document.getElementById('popupNew');
const popupOld = document.getElementById('popupOld');
let lastAreas = [];

obj.addEventListener('load', ()=> {
  try {
    const svgDoc = obj.contentDocument;
    const svg = svgDoc.querySelector('svg');
    if(!svg) { console.error('SVG not found inside object'); return; }

    // attempt to hide a giant black frame element (heuristic)
    try{
      Array.from(svg.querySelectorAll('path,rect')).forEach(el=>{
        try{
          const bb = el.getBBox();
          const svgBB = svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width ? (svg.viewBox.baseVal.width * svg.viewBox.baseVal.height) : (svg.clientWidth*svg.clientHeight);
          if(bb && svgBB){
            const area = bb.width*bb.height;
            if(area / svgBB > 0.5){
              const stroke = (el.getAttribute('stroke')||'').toLowerCase();
              const sw = parseFloat(el.getAttribute('stroke-width')||0);
              if((stroke.includes('black') || stroke === '#000' || sw > 3)){
                el.style.display = 'none';
              }
            }
          }
        }catch(e){}
      });
    }catch(e){}

    // find area elements (prefer having title)
    const candidates = Array.from(svg.querySelectorAll('path,polygon,rect,g'));
    const areas = candidates.filter(el=>{
      const t = el.querySelector && el.querySelector('title');
      return (t && t.textContent && t.textContent.trim()) || (el.id && el.id.trim());
    });
    const targetEls = areas.length ? areas : Array.from(svg.querySelectorAll('path'));
    lastAreas = targetEls;

    // color each element by group
    targetEls.forEach(el=>{
      // read title chinese name
      let titleText = '';
      try { const t = el.querySelector && el.querySelector('title'); if(t) titleText = t.textContent.trim(); } catch(e){}
      let name = '';
      if(titleText) {
        const m = titleText.match(/^[\u4e00-\u9fff]+/);
        if(m && m[0]) name = m[0].replace(/å€$/,'');
      }
      if(!name) name = (el.id||'').replace(/^_+/,'') || '';
      el.dataset.name = name;

      // color
      const g = findGroup(name);
      if(g){
        const base = groupColor[g];
        // apply only if no fill or white
        const curFill = (el.getAttribute('fill')||'').toLowerCase();
        if(!curFill || curFill === 'none' || curFill === '#ffffff' || curFill === 'white'){
          el.setAttribute('fill', base);
        }
      }
      // stroke
      el.setAttribute('stroke','#ffffff');
      el.setAttribute('stroke-width','1');

      // click handler: show popup
      const onClick = (ev) => {
        ev.stopPropagation();
        showPopup(name, ev);
      };
      el.addEventListener('click', onClick);
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); onClick(e); });
    });

    // create labels overlay by computing each element's screen bbox and centering an HTML div
    function placeLabels(){
      labelsLayer.innerHTML = '';
      const stageRect = document.getElementById('stage').getBoundingClientRect();
      targetEls.forEach(el=>{
        try{
          const bbox = el.getBoundingClientRect(); // screen coords
          if(bbox.width < 6 && bbox.height < 6) return; // skip tiny
          const cx = bbox.left + bbox.width/2;
          const cy = bbox.top + bbox.height/2;
          // convert to labelsLayer coordinates
          const lx = cx - stageRect.left;
          const ly = cy - stageRect.top;

          const name = el.dataset.name || '';
          const pd = placeData[name] || {};
          // create label div
          const div = document.createElement('div');
          div.className = 'label';
          div.style.left = lx + 'px';
          div.style.top = ly + 'px';
          div.innerHTML = `<div class="new">${pd.new_ch || name}</div><div class="old">${pd.old_ch || ''}</div>`;
          labelsLayer.appendChild(div);
        }catch(e){}
      });
    }

    // initial placement after small delay (allow rendering)
    setTimeout(placeLabels, 300);

    // reposition on resize & scroll & object resize
    window.addEventListener('resize', ()=> setTimeout(placeLabels,200));
    window.addEventListener('scroll', ()=> setTimeout(placeLabels,200));
    // also periodically reposition in case object scales later
    let repositionTimer = setInterval(placeLabels, 1200);
    // stop reposition after some seconds to avoid infinite timer
    setTimeout(()=> clearInterval(repositionTimer), 8000);

    // clicking outside closes popup
    document.addEventListener('click', ()=> { document.getElementById('popup').style.display = 'none'; });

  } catch(err){
    console.error('object load error', err);
  }
});

/* popup handler */
function showPopup(name, ev){
  const pd = placeData[name] || {};
  document.getElementById('popupNew').textContent = (pd.new_ch || name);
  document.getElementById('popupOld').textContent = (pd.old_ch || '');
  const stage = document.getElementById('stage');
  const rect = stage.getBoundingClientRect();
  let clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (rect.left + rect.width/2);
  let clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || (rect.top + rect.height/2);
  let left = clientX - rect.left + 8;
  let top = clientY - rect.top + 8;
  const popupEl = document.getElementById('popup');
  const pw = Math.min(320, rect.width - 16), ph = 160;
  if(left + pw > rect.width) left = Math.max(8, clientX - rect.left - pw - 8);
  if(top + ph > rect.height) top = Math.max(8, clientY - rect.top - ph - 8);
  popupEl.style.left = left + 'px';
  popupEl.style.top = top + 'px';
  popupEl.style.display = 'block';
}
</script>
</body>
</html>
