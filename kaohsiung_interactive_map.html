<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–</title>
<style>
  :root{
    --bg:#f9f6ef;
    --title-color:#222;
    --new-color:#c0392b;
    --old-color:#555;
    --label-font: "Noto Sans TC", "Microsoft JhengHei", system-ui, -apple-system, Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:var(--label-font); color:var(--title-color)}
  .page{display:flex; flex-direction:column; align-items:center; gap:6px; padding:10px; box-sizing:border-box;}
  h1{margin:8px 0 0 0; font-size:1.25rem; text-align:center;}
  .subtitle{margin:0; font-size:0.95rem; color:#666; text-align:center;}

  .map-stage{
    width:100%;
    max-width:980px;
    height: calc(100vh - 170px);
    max-height:1200px;
    background:transparent;
    border-radius:10px;
    overflow:hidden;
    position:relative;
    box-shadow: 0 8px 20px rgba(0,0,0,0.06);
  }

  object#svgObject{ width:100%; height:100%; display:block; border:0; }

  /* HTML overlay labels (two-line, centered) */
  #labelsLayer{ position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; z-index:30; }
  .label{
    position:absolute;
    transform: translate(-50%,-50%);
    text-align:center;
    white-space:nowrap;
    pointer-events:none;
    line-height:1.05;
  }
  .label .new { font-weight:700; color:var(--new-color); font-size:13px; text-shadow: 0 1px 0 rgba(255,255,255,0.2);}
  .label .old { font-weight:400; color:var(--old-color); font-size:13px; margin-top:2px; text-shadow: 0 1px 0 rgba(255,255,255,0.2); }

  /* popup */
  .popup{ position:absolute; display:none; min-width:220px; max-width:320px; background:#fff; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,0.18); border:1px solid rgba(0,0,0,0.08); padding:10px 12px; z-index:60; }
  .popup h3{ margin:0 0 6px 0; font-size:1rem }
  .muted{ color:#666; font-size:0.95rem }
  .audioRow{ display:flex; gap:10px; margin-top:8px }
  .audioBtn{ background:#ddd; border-radius:8px; padding:8px 10px; border:none; color:#666; cursor:not-allowed }

  .note{ margin-top:6px; color:#555; font-size:0.90rem; text-align:center; }

  @media (max-width:640px){
    .map-stage{ height: calc(100vh - 140px); }
    .label .new, .label .old { font-size:14px; }
    .popup{ min-width:72%; left:14% !important; right:auto }
  }
</style>
</head>
<body>
  <div class="page">
    <h1>é«˜é›„å¸‚38å€æ–°èˆŠåœ°åäº’å‹•åœ°åœ–</h1>
    <div class="subtitle">ğŸ“± å»ºè­°ç›´å¼è§€çœ‹æ•ˆæœæœ€ä½³</div>

    <div class="map-stage" id="stage">
      <!-- object è¼‰å…¥ SVGï¼›è‹¥ä½ è¦æ”¹æˆç›¸å°è·¯å¾‘ï¼Œå¯æŠŠ RAW_SVG_URL æ”¹ç‚º "map_assets/Blank_Kaohsiung_map.svg" -->
      <object id="svgObject" type="image/svg+xml" data="https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg"></object>

      <!-- html overlay for labels -->
      <div id="labelsLayer"></div>

      <!-- popup -->
      <div id="popup" class="popup" role="dialog" aria-live="polite">
        <h3 id="popupNew">æ–°åœ°å</h3>
        <div id="popupOld" class="muted">èˆŠåœ°å</div>
        <div class="audioRow">
          <button class="audioBtn" id="btnNew">ğŸ”ˆ æ–°åœ°åï¼ˆé ç•™ï¼‰</button>
          <button class="audioBtn" id="btnOld">ğŸ”ˆ èˆŠåœ°åï¼ˆé ç•™ï¼‰</button>
        </div>
      </div>
    </div>

    <div class="note">â€» æœ¬åœ–ç‚ºåŸºç¤åœ°åœ–ï¼Œå¾ŒçºŒæœƒæ‹†æˆ 4 å›éŠæˆ²ï¼ˆæœ¬ç‰ˆæœ¬å·²ä»¥å››å¤§è‰²ç³»å€åˆ†ç¾¤çµ„ä¸¦é¡¯ç¤ºæ–°ï¼èˆŠä¸­æ–‡ï¼‰ã€‚</div>
  </div>

<script>
/* === Configuration === */
const RAW_SVG_URL = 'https://raw.githubusercontent.com/tsong-su/iuhi/main/map_assets/Blank_Kaohsiung_map.svg';

/* group definitions (no 'å€') */
const groups = {
  center: ["æ¥ æ¢“","å·¦ç‡Ÿ","é¼“å±±","ä¸‰æ°‘","é¹½åŸ•","å‰é‡‘","æ–°èˆˆ","è‹“é›…","æ——æ´¥","å‰é®","å°æ¸¯"],
  east:   ["å¤§æ¨¹","å¤§å¯®","æ—åœ’","å¤§ç¤¾","ä»æ­¦","é³¥æ¾","é³³å±±"],
  north:  ["èŒ„è£","æ°¸å®‰","å½Œé™€","æ¢“å®˜","æ¹–å…§","è·¯ç«¹","å²¡å±±","æ©‹é ­","é˜¿è“®","ç”°å¯®","ç‡•å·¢"],
  mount:  ["å…§é–€","æ——å±±","æ‰æ—","ç¾æ¿ƒ","ç”²ä»™","å…­é¾œ","é‚£ç‘ªå¤","æ¡ƒæº","èŒ‚æ—"]
};

const groupColor = { center:'#ffb3b3', east:'#d1b3ff', north:'#d4f5b3', mount:'#b3e6e6' };

/* placeData: only Chinese new_ch / old_ch for labels */
const placeData = {
  "æ¥ æ¢“": { new_ch:"æ¥ æ¢“", old_ch:"æ¥ ä»”å‘" },
  "å·¦ç‡Ÿ": { new_ch:"å·¦ç‡Ÿ", old_ch:"èˆˆéš†é‡Œ" },
  "é¼“å±±": { new_ch:"é¼“å±±", old_ch:"æ‰“ç‹—å±±" },
  "ä¸‰æ°‘": { new_ch:"ä¸‰æ°‘", old_ch:"ä¸‰å¡Šå" },
  "é¹½åŸ•": { new_ch:"é¹½åŸ•", old_ch:"é¹½åŸ•åŸ”" },
  "å‰é‡‘": { new_ch:"å‰é‡‘", old_ch:"å‰è¡¿" },
  "æ–°èˆˆ": { new_ch:"æ–°èˆˆ", old_ch:"é€®æ¸¯åŸ”" },
  "è‹“é›…": { new_ch:"è‹“é›…", old_ch:"ç¬­ä»”å¯®" },
  "æ——æ´¥": { new_ch:"æ——æ´¥", old_ch:"æ——å¾Œ" },
  "å‰é®": { new_ch:"å‰é®", old_ch:"å‰é®" },
  "å°æ¸¯": { new_ch:"å°æ¸¯", old_ch:"æ¸¯ä»”å¢˜" },

  "å¤§æ¨¹": { new_ch:"å¤§æ¨¹", old_ch:"å¤§æ¨¹è·¤" },
  "å¤§å¯®": { new_ch:"å¤§å¯®", old_ch:"å¤§è—”" },
  "æ—åœ’": { new_ch:"æ—åœ’", old_ch:"é ‚æ—ä»”é‚Š" },
  "å¤§ç¤¾": { new_ch:"å¤§ç¤¾", old_ch:"ä¸‰å¥¶å£‡" },
  "ä»æ­¦": { new_ch:"ä»æ­¦", old_ch:"ä»æ­¦é®" },
  "é³¥æ¾": { new_ch:"é³¥æ¾", old_ch:"é³¥æ¾è·¤" },
  "é³³å±±": { new_ch:"é³³å±±", old_ch:"ä¸‹åŸ¤é ­" },

  "èŒ„è£": { new_ch:"èŒ„è£", old_ch:"èŒ„è‹³è£ä»”" },
  "æ°¸å®‰": { new_ch:"æ°¸å®‰", old_ch:"çƒæ¨¹æ—" },
  "å½Œé™€": { new_ch:"å½Œé™€", old_ch:"å½Œé™€æ¸¯" },
  "æ¢“å®˜": { new_ch:"æ¢“å®˜", old_ch:"æ¢“å®˜" },
  "æ¹–å…§": { new_ch:"æ¹–å…§", old_ch:"å¤§æ¹–" },
  "è·¯ç«¹": { new_ch:"è·¯ç«¹", old_ch:"åŠè·¯ç«¹" },
  "å²¡å±±": { new_ch:"å²¡å±±", old_ch:"é˜¿å…¬åº—" },
  "æ©‹é ­": { new_ch:"æ©‹é ­", old_ch:"æ©‹ä»”é ­" },
  "é˜¿è“®": { new_ch:"é˜¿è“®", old_ch:"é˜¿å—¹ç¤¾" },
  "ç”°å¯®": { new_ch:"ç”°å¯®", old_ch:"ç”°è—”" },
  "ç‡•å·¢": { new_ch:"ç‡•å·¢", old_ch:"æ´å‰¿å³" },

  "å…§é–€": { new_ch:"å…§é–€", old_ch:"ç¾…æ¼¢å…§é–€" },
  "æ——å±±": { new_ch:"æ——å±±", old_ch:"è•ƒè–¯è—”" },
  "æ‰æ—": { new_ch:"æ‰æ—", old_ch:"æ¥ æ¢“ä»™" },
  "ç¾æ¿ƒ": { new_ch:"ç¾æ¿ƒ", old_ch:"ç€°æ¿ƒ" },
  "ç”²ä»™": { new_ch:"ç”²ä»™", old_ch:"é˜¿é‡Œé—œ" },
  "å…­é¾œ": { new_ch:"å…­é¾œ", old_ch:"å…­é¾œé‡Œç¤¾" },
  "é‚£ç‘ªå¤": { new_ch:"é‚£ç‘ªå¤", old_ch:"èšŠå­åª" },
  "æ¡ƒæº": { new_ch:"æ¡ƒæº", old_ch:"é›…çˆ¾" },
  "èŒ‚æ—": { new_ch:"èŒ‚æ—", old_ch:"å±¯ä»”" }
};

/* helper to find which group a name belongs to */
function findGroup(name){
  for(const k in groups) if(groups[k].includes(name)) return k;
  return null;
}

/* === Main: when object loads, color areas, create overlay labels, bind events === */
const obj = document.getElementById('svgObject');
const labelsLayer = document.getElementById('labelsLayer');
const popup = document.getElementById('popup');
const popupNew = document.getElementById('popupNew');
const popupOld = document.getElementById('popupOld');

obj.addEventListener('load', () => {
  try{
    const svgDoc = obj.contentDocument;
    const svg = svgDoc.querySelector('svg');
    if(!svg) { console.error('SVG not found'); return; }

    // ensure viewBox/preserveAspectRatio present if missing
    if(!svg.getAttribute('viewBox')){
      const w = svg.getAttribute('width') || svg.viewBox.baseVal.width || svg.clientWidth;
      const h = svg.getAttribute('height') || svg.viewBox.baseVal.height || svg.clientHeight;
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');

    // hide any very large black frame paths/rects (heuristic)
    try{
      Array.from(svg.querySelectorAll('path,rect')).forEach(el=>{
        try{
          const bb = el.getBBox();
          const vb = svg.viewBox.baseVal;
          const svgArea = vb && vb.width && vb.height ? vb.width * vb.height : (svg.clientWidth * svg.clientHeight);
          const area = bb.width * bb.height;
          if(svgArea && (area / svgArea) > 0.5){
            const stroke = (el.getAttribute('stroke') || '').toLowerCase();
            const sw = parseFloat(el.getAttribute('stroke-width') || 0);
            if((stroke.includes('black') || stroke === '#000' || sw > 3)){
              el.style.display = 'none';
            }
          }
        }catch(e){}
      });
    }catch(e){}

    // pick candidate area elements (prefer elements with <title>)
    const candidates = Array.from(svg.querySelectorAll('path,polygon,rect,g'));
    const areas = candidates.filter(el=>{
      const t = el.querySelector && el.querySelector('title');
      return (t && t.textContent && t.textContent.trim()) || (el.id && el.id.trim());
    });
    const targetEls = areas.length ? areas : Array.from(svg.querySelectorAll('path'));

    // color areas, set stroke, and bind click
    targetEls.forEach(el => {
      // read title (e.g. "å°æ¸¯å€ Xiaogang District")
      let titleText = '';
      try{ const t = el.querySelector && el.querySelector('title'); if(t) titleText = t.textContent.trim(); }catch(e){}
      let name = '';
      if(titleText){
        const m = titleText.match(/^[\u4e00-\u9fff]+/);
        if(m && m[0]) name = m[0].replace(/å€$/,'');
      }
      if(!name) name = (el.id||'').replace(/^_+/,'') || '';

      el.dataset.name = name;

      // apply group color only if fill is none/white/empty
      const g = findGroup(name);
      if(g){
        const base = groupColor[g];
        const curFill = (el.getAttribute('fill')||'').toLowerCase();
        if(!curFill || curFill === 'none' || curFill === '#ffffff' || curFill === 'white') {
          el.setAttribute('fill', base);
        }
      }
      el.setAttribute('stroke','#ffffff');
      el.setAttribute('stroke-width','1');

      // click -> popup
      const onClick = (ev) => { ev.stopPropagation(); showPopup(name, ev); };
      el.addEventListener('click', onClick);
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); onClick(e); });
      el.addEventListener('mouseenter', ()=> el.style.filter = 'brightness(1.06)');
      el.addEventListener('mouseleave', ()=> el.style.filter = '');
    });

    // function to place HTML labels overlay based on element screen bbox
    function placeLabels(){
      labelsLayer.innerHTML = '';
      const stageRect = document.getElementById('stage').getBoundingClientRect();
      targetEls.forEach(el => {
        try{
          const bbox = el.getBoundingClientRect(); // screen coords
          if(bbox.width < 6 && bbox.height < 6) return;
          const cx = bbox.left + bbox.width/2;
          const cy = bbox.top + bbox.height/2;
          const lx = cx - stageRect.left;
          const ly = cy - stageRect.top;

          const name = el.dataset.name || '';
          const pd = placeData[name] || {};
          const div = document.createElement('div');
          div.className = 'label';
          div.style.left = lx + 'px';
          div.style.top = ly + 'px';
          div.innerHTML = `<div class="new">${pd.new_ch || name}</div><div class="old">${pd.old_ch || ''}</div>`;
          labelsLayer.appendChild(div);
        }catch(e){}
      });
    }

    // initial placement (delay to allow rendering)
    setTimeout(placeLabels, 250);
    // reposition on window resize/scroll
    window.addEventListener('resize', ()=> setTimeout(placeLabels,120));
    window.addEventListener('scroll', ()=> setTimeout(placeLabels,120));
    // periodic reposition for a few seconds to catch late rendering
    let t = setInterval(placeLabels, 900);
    setTimeout(()=> clearInterval(t), 7000);

    // click outside popup closes it
    document.addEventListener('click', ()=> { document.getElementById('popup').style.display = 'none'; });

  }catch(err){
    console.error('SVG processing error:', err);
  }
});

/* popup show */
function showPopup(name, ev){
  const pd = placeData[name] || {};
  document.getElementById('popupNew').textContent = (pd.new_ch || name);
  document.getElementById('popupOld').textContent = (pd.old_ch || '');

  const stageRect = document.getElementById('stage').getBoundingClientRect();
  let clientX = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (stageRect.left + stageRect.width/2);
  let clientY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || (stageRect.top + stageRect.height/2);
  let left = clientX - stageRect.left + 8;
  let top = clientY - stageRect.top + 8;
  const popupEl = document.getElementById('popup');
  const pw = Math.min(320, stageRect.width - 16), ph = 160;
  if(left + pw > stageRect.width) left = Math.max(8, clientX - stageRect.left - pw - 8);
  if(top + ph > stageRect.height) top = Math.max(8, clientY - stageRect.top - ph - 8);
  popupEl.style.left = left + 'px';
  popupEl.style.top = top + 'px';
  popupEl.style.display = 'block';
}
</script>
</body>
</html>
