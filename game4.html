<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>è‡ºç£åŒ—éƒ¨åœ°åœ–&æ³¨éŸ³ç¬¦è™Ÿéƒµç¥¨é…å°éŠæˆ²</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ç‰ˆé¢ï¼šå–®ä¸€å…¨è¢å¹•å®¹å™¨ï¼Œåœ°åœ–å®Œæ•´å¯è¦‹ï¼ˆobject-fit: containï¼‰ */
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden; /* ä¿è­‰ä¸å‡ºç¾æ²è»¸ */
      background: #f5f5f5;
      font-family: "Microsoft JhengHei", Arial, sans-serif;
    }
    #game {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #f5f5f5;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    #map {
      position: absolute;
      inset: 0;              /* top:0; right:0; bottom:0; left:0 */
      width: 100%;
      height: 100%;
      object-fit: contain;   /* << é—œéµï¼šå®Œæ•´å¡å…¥è¦–çª— */
      pointer-events: none;  /* é¿å…æŠ“åˆ°åœ–ç‰‡æœ¬èº«ï¼Œæ‹–æ›³æ›´é † */
      display: block;
    }

    /* HUDï¼ˆæµ®åœ¨åœ°åœ–ä¸Šï¼Œä¸ä½”ç‰ˆé¢é«˜åº¦ï¼‰ */
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 1000;
      background: rgba(255,255,255,0.85);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.08);
      display: flex;
      align-items: center;
      gap: 14px;
    }
    #title {
      font-size: 24px;
      font-weight: 700;
      margin: 0;
      white-space: nowrap;
    }
    #home {
      font-size: 18px;
      color: #0b63d1;
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 8px;
      background: #eaf3ff;
    }
    #home:hover { background: #d8e9ff; }
    #shuffle {
      font-size: 16px;
      padding: 8px 12px;
      border-radius: 10px;
      border: none;
      background: #0b63d1;
      color: #fff;
      cursor: pointer;
    }
    #shuffle:hover { background: #094fa7; }

    /* ç´…è‰²å°è™›ç·šæ¡†ï¼ˆå¤§å°èˆ‡éƒµç¥¨åŒæ­¥ï¼Œç”± JS è¨­ px å€¼ï¼‰ */
    .slot {
      position: absolute;
      border: 3px dashed red;
      box-sizing: border-box;
      pointer-events: none;
      z-index: 50;
    }

    /* éƒµç¥¨ï¼ˆå¤§å°ç”± JS è¨­ px å€¼ï¼›æ°¸é ç›¸å°å®¹å™¨å®šä½ï¼‰ */
    .stamp {
      position: absolute;
      cursor: grab;
      z-index: 60;
      touch-action: none; /* é¿å…æ‰‹æ©Ÿç€è¦½å™¨æŠŠæ‹–æ›³ç•¶ä½œæ²å‹• */
    }
    .stamp:active { cursor: grabbing; }

    /* å‹åˆ©è¨Šæ¯ */
    #victory {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 56px;
      font-weight: 900;
      color: #1f9d55;
      text-shadow: 0 2px 8px rgba(0,0,0,0.15);
      display: none;
      z-index: 1200;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="game">
    <img id="map" src="game4_assets/north2_map.png" alt="åŒ—éƒ¨åœ°åœ–" />

    <div id="hud">
      <h1 id="title">è‡ºç£åŒ—éƒ¨åœ°åœ–&æ³¨éŸ³ç¬¦è™Ÿéƒµç¥¨é…å°éŠæˆ²</h1>
      <a id="home" href="index.html">ğŸ  å›åˆ°éŠæˆ²é¦–é </a>
      <button id="shuffle">ğŸ”„ é‡æ’éƒµç¥¨</button>
    </div>

    <div id="victory">æœ‰å¤  gÃ¢uï¼</div>
  </div>

  <script>
    /* === ä½ æä¾›çš„æ¯”ä¾‹åº§æ¨™ï¼Œåš´æ ¼ä½¿ç”¨ï¼Œä¸è®Šå‹•ä½ç½® === */
    const basePositions = [
      {"x":0.9953,"y":0.1551},
      {"x":0.7589,"y":0.0012},
      {"x":0.5749,"y":0.0249},
      {"x":0.3782,"y":0.1872},
      {"x":0.1291,"y":0.1264},
      {"x":0.115,"y":0.3242},
      {"x":0.0077,"y":0.5255},
      {"x":0.0435,"y":0.9668},
      {"x":0.2479,"y":0.9922},
      {"x":0.4791,"y":0.9043},
      {"x":0.7372,"y":0.4916},
      {"x":0.9173,"y":0.4409}
    ];

    /* === ä¸»è¦ç¯€é» === */
    const game = document.getElementById('game');
    const map  = document.getElementById('map');
    const victoryEl = document.getElementById('victory');
    const shuffleBtn = document.getElementById('shuffle');

    /* === éŸ³æ•ˆï¼ˆå­˜åœ¨å°±æ’­ï¼Œä¸å­˜åœ¨ä¹Ÿä¸æœƒå ±éŒ¯ï¼‰ === */
    const sfx = {
      correct: new Audio('game4_assets/correct.mp3'),
      wrong:   new Audio('game4_assets/wrong.mp3'),
      victory: new Audio('game4_assets/victory.mp3')
    };
    Object.values(sfx).forEach(a => a.addEventListener('error', () => {/* éœéŸ³è™•ç† */}));

    /* === ç‹€æ…‹ === */
    const slots = [];   // ç´…æ¡† DOM
    const stamps = [];  // éƒµç¥¨ DOM
    let placedCount = 0;

    /* === è¨ˆç®—ã€Œåœ–ç‰‡å¯¦éš›é¡¯ç¤ºå€åŸŸã€ç›¸å°æ–¼å®¹å™¨çš„ç›’å­ ===
       object-fit: contain çš„æ­£ç¢ºå®šä½æ–¹å¼ï¼š
       - å…ˆç”¨åœ–ç‰‡åŸå§‹æ¯”ä¾‹èˆ‡å®¹å™¨å°ºå¯¸æ±‚ scale
       - å¾—åˆ°é¡¯ç¤ºå¯¬é«˜ displayW/H
       - å†ç®—å·¦å³/ä¸Šä¸‹ letterbox çš„ offsetX/offsetY
       - æ‰€æœ‰ç´…æ¡†/éƒµç¥¨å®šä½éƒ½ç”¨é€™å€‹ç›’å­çš„åº§æ¨™ç³»
    ===================================================== */
    function getDisplayBox() {
      const cw = game.clientWidth;
      const ch = game.clientHeight;
      const natW = map.naturalWidth || 1284; // é€€é¿å€¼ï¼Œé¿å…æ¥µç«¯æƒ…æ³
      const natH = map.naturalHeight || 970;

      const scale = Math.min(cw / natW, ch / natH);
      const displayW = natW * scale;
      const displayH = natH * scale;
      const offsetX = (cw - displayW) / 2;
      const offsetY = (ch - displayH) / 2;

      return { displayW, displayH, offsetX, offsetY, scale };
    }

    /* === å»ºç«‹ç´…æ¡† === */
    function buildSlots() {
      // å…ˆæ¸…ç©ºèˆŠçš„
      slots.splice(0, slots.length).forEach(el => el.remove());

      const { displayW, displayH, offsetX, offsetY } = getDisplayBox();
      const size = displayW * 0.06; // å›ºå®š 6% åœ°åœ–å¯¬åº¦

      basePositions.forEach((pos, i) => {
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.style.width  = size + 'px';
        slot.style.height = size + 'px';
        // ä»¥é¡¯ç¤ºç›’å­çš„åº§æ¨™ç‚ºåŸºæº–å®šä½ï¼ˆä¸å†ç”¨è¦–çª—åº§æ¨™ï¼‰
        slot.style.left = (offsetX + pos.x * displayW - size / 2) + 'px';
        slot.style.top  = (offsetY + pos.y * displayH - size / 2) + 'px';
        game.appendChild(slot);
        slots.push(slot);
      });
    }

    /* === å»ºç«‹éƒµç¥¨ === */
    function buildStamps() {
      stamps.splice(0, stamps.length).forEach(el => el.remove());

      const { displayW } = getDisplayBox();
      const size = displayW * 0.06;

      basePositions.forEach((pos, i) => {
        const img = document.createElement('img');
        img.className = 'stamp';
        img.src = `game4_assets/stamp${i+1}.jpg`; // â† ä¾ä½ çš„æª”æ¡ˆç‚º .jpg
        img.style.width = size + 'px';
        img.dataset.index = i;
        game.appendChild(img);
        stamps.push(img);
      });

      // åˆå§‹éš¨æ©Ÿæ•£è½ï¼ˆé¿å…é‡ç–Šã€æ•£åœ¨å››å‘¨ï¼‰
      scatterStamps();
      // å•Ÿç”¨æ‹–æ›³
      enableDragging();
    }

    /* === å››å‘¨æ•£è½ + é¿å…é‡ç–Š === */
    function scatterStamps() {
      const { displayW, displayH, offsetX, offsetY } = getDisplayBox();
      const size = displayW * 0.06;
      const band = size + 12;      // å››å‘¨å¸¶
      const minGap = size * 0.6;   // æœ€å°é–“è·ï¼Œé¿å…é‡ç–Šå¤ªå¤š
      const placed = [];

      function farEnough(x, y) {
        return placed.every(p => {
          const dx = p.x - x, dy = p.y - y;
          return (dx*dx + dy*dy) >= (minGap*minGap);
        });
      }

      stamps.forEach(st => {
        let x, y, tries = 0;
        do {
          // éš¨æ©Ÿé¸ä¸€å€‹é‚Šå¸¶ï¼šä¸Š/ä¸‹/å·¦/å³
          const edge = Math.floor(Math.random()*4);
          if (edge === 0) { // ä¸Š
            x = offsetX + Math.random()*(displayW - size);
            y = offsetY + 6; // å¾®ç•™ç™½
          } else if (edge === 1) { // ä¸‹
            x = offsetX + Math.random()*(displayW - size);
            y = offsetY + displayH - size - 6;
          } else if (edge === 2) { // å·¦
            x = offsetX + 6;
            y = offsetY + Math.random()*(displayH - size);
          } else { // å³
            x = offsetX + displayW - size - 6;
            y = offsetY + Math.random()*(displayH - size);
          }
          tries++;
          if (tries > 80) break; // ä¿åº•é¿å…æ­»å¾ªç’°
        } while (!farEnough(x, y));

        placed.push({x, y});
        st.style.left = x + 'px';
        st.style.top  = y + 'px';
        st.style.pointerEvents = 'auto';
      });
    }

    /* === æ‹–æ›³ï¼ˆä»¥å®¹å™¨åº§æ¨™ç‚ºåŸºæº–ï¼Œæ»‘é¼ /æ‰‹æŒ‡åŒæ­¥ï¼‰ === */
    function enableDragging() {
      let dragging = null;
      let grabDX = 0, grabDY = 0;

      function toLocal(clientX, clientY) {
        const r = game.getBoundingClientRect();
        return { x: clientX - r.left, y: clientY - r.top };
      }

      function onPointerDown(e) {
        const t = e.target;
        if (!t.classList.contains('stamp')) return;
        dragging = t;
        dragging.setPointerCapture?.(e.pointerId);
        const rect = dragging.getBoundingClientRect();
        const gameRect = game.getBoundingClientRect();
        grabDX = e.clientX - rect.left;
        grabDY = e.clientY - rect.top;
        e.preventDefault();
      }

      function onPointerMove(e) {
        if (!dragging) return;
        const gameRect = game.getBoundingClientRect();
        const x = e.clientX - gameRect.left - grabDX;
        const y = e.clientY - gameRect.top  - grabDY;
        dragging.style.left = x + 'px';
        dragging.style.top  = y + 'px';
      }

      function onPointerUp(e) {
        if (!dragging) return;
        checkDrop(dragging);
        dragging.releasePointerCapture?.(e.pointerId);
        dragging = null;
      }

      // ç¶å®šåœ¨ game å®¹å™¨ä¸Šï¼ˆæ”¯æ´æ»‘é¼  + è§¸æ§ï¼‰
      game.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
    }

    /* === é…å°æª¢æŸ¥ === */
    function checkDrop(stamp) {
      const idx = Number(stamp.dataset.index);
      const slot = slots[idx];
      const slotRect = slot.getBoundingClientRect();
      const stampRect = stamp.getBoundingClientRect();

      const size = slotRect.width; // èˆ‡éƒµç¥¨ä¸€è‡´
      const hit =
        Math.abs((slotRect.left) - (stampRect.left)) < size / 3 &&
        Math.abs((slotRect.top ) - (stampRect.top )) < size / 3;

      if (hit) {
        // å°é½Šåˆ°ç´…æ¡†
        stamp.style.left = slot.style.left;
        stamp.style.top  = slot.style.top;
        stamp.style.pointerEvents = 'none';
        placedCount++;
        sfx.correct.play().catch(()=>{});
        if (placedCount === basePositions.length) {
          victoryEl.style.display = 'block';
          sfx.victory.play().catch(()=>{});
        }
      } else {
        sfx.wrong.play().catch(()=>{});
      }
    }

    /* === è¦–çª—å°ºå¯¸è®ŠåŒ–æ™‚ï¼šé‡ç®—é¡¯ç¤ºç›’å­ã€é‡å»ºç´…æ¡†èˆ‡éƒµç¥¨å¤§å°èˆ‡ä½ç½® ===
       ï¼ˆå·²æ”¾ä¸‹çš„éƒµç¥¨ä¸ä¿ç•™åº§æ¨™ï¼Œç›´æ¥ä¾ç›®å‰ç‰ˆé¢é‡è¨ˆä¸¦é‡æ–°æ•£è½ï¼Œ
        é€™æ¨£å¯ä»¥é¿å…ä»»ä½•ç¸®æ”¾é€ æˆçš„ä½ç§»éŒ¯è¦ºã€‚ï¼‰ */
    function layoutAll() {
      placedCount = 0;
      victoryEl.style.display = 'none';
      buildSlots();
      buildStamps();
    }

    /* === äº‹ä»¶ === */
    shuffleBtn.addEventListener('click', scatterStamps);

    // ç­‰åœ–ç‰‡çœŸçš„è¼‰å…¥å¾Œå†é€²è¡Œç‰ˆé¢è¨ˆç®—ï¼ˆnaturalWidth/Height æ‰å¯é ï¼‰
    function start() {
      if (map.naturalWidth && map.naturalHeight) {
        layoutAll();
      } else {
        map.addEventListener('load', layoutAll, { once: true });
      }
    }

    window.addEventListener('resize', layoutAll);
    window.addEventListener('orientationchange', layoutAll);
    start();
  </script>
</body>
</html>
