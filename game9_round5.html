<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æœå­éª°ä»”éŠæˆ²-ç¬¬1å›</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
<style>
:root{
  --roll-btn: #ff6b35;
  --again-btn: #4caf50;
  --next-btn: #2196f3;
  --home-btn: #9c27b0;
  --bg1: #fffbea;
  --cube-border-color: #c74444;
  --cube-border: 6px solid var(--cube-border-color);
  --cube-border-radius: 12px;
}
*{ box-sizing:border-box; }
body{
  margin:0; min-height:100vh; font-family:"Noto Sans TC","Microsoft JhengHei",sans-serif;
  background:var(--bg1); display:flex; flex-direction:column; align-items:center;
  color:#222;
}
header{ text-align:center; padding:14px 10px 4px; width:100%; }
h1{ margin:0; font-size:6.5vw; color:#d94f4f; line-height:1; }
.hint{ margin-top:8px; font-size:4.8vw; color:#ff6600; font-weight:700; }

main{ width:100%; max-width:520px; padding:8px 12px 18px; display:flex; flex-direction:column; align-items:center; gap:8px; flex:1 1 auto; }

.cube-wrap{ width:100%; display:flex; justify-content:center; align-items:center; }
.cube-stage{
  width: min(90vw, 200px);
  height: min(90vw, 200px);
  max-width:200px;
  max-height:200px;
  perspective:1200px;
  display:flex; align-items:center; justify-content:center;
}

/* cube size via --cube-size */
.cube {
  width: var(--cube-size);
  height: var(--cube-size);
  position:relative;
  transform-style:preserve-3d;
  transition: transform 1800ms cubic-bezier(.19,.57,.3,.98);
}

/* postcard / stamp edge feel: thicker colored border + subtle inner shadow */
.face{
  position:absolute; left:0; top:0;
  width:100%; height:100%;
  border-radius:var(--cube-border-radius);
  overflow:hidden;
  display:flex; align-items:center; justify-content:center;
  background:#fff; box-shadow: 0 12px 22px rgba(0,0,0,0.12), inset 0 0 0 2px rgba(0,0,0,0.02);
  border:var(--cube-border);
  backface-visibility:hidden;
}
.face img{ width:92%; height:92%; object-fit:contain; display:block; border-radius:8px; }

.face.front  { transform: rotateY(0deg)    translateZ(calc(var(--cube-size)/2)); }
.face.back   { transform: rotateY(180deg)  translateZ(calc(var(--cube-size)/2)); }
.face.right  { transform: rotateY(90deg)   translateZ(calc(var(--cube-size)/2)); }
.face.left   { transform: rotateY(-90deg)  translateZ(calc(var(--cube-size)/2)); }
.face.top    { transform: rotateX(90deg)   translateZ(calc(var(--cube-size)/2)); }
.face.bottom { transform: rotateX(-90deg)  translateZ(calc(var(--cube-size)/2)); }

#result {
  width:100%; min-height:120px; display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:8px;
}
.fruit-name{ font-size:6.5vw; color:#ff4081; font-weight:800; line-height:1; }
.fruit-roman{ font-size:5vw; color:#009688; font-weight:700; margin-top:4px; }
.play-audio{
  margin-top:8px; padding:8px 18px; border-radius:12px; border:none; background:#3f51b5; color:#fff; font-weight:700;
  font-size:4.6vw; cursor:pointer;
}

.controls{ display:flex; gap:8px; justify-content:center; align-items:center; width:100%; margin-top:6px; }
#rollBtn{
  background:var(--roll-btn); color:#fff; border:none; border-radius:12px; padding:12px 20px; font-weight:800;
  font-size:5.2vw; cursor:pointer; box-shadow: 0 8px 20px rgba(0,0,0,0.12);
}

.bottom{ width:100%; padding:12px 10px 22px; display:flex; justify-content:center; gap:10px; }
.bottom button{ border:none; padding:10px 12px; border-radius:12px; color:#fff; font-weight:800; cursor:pointer; font-size:4.6vw; }
#againBtn{ background:var(--again-btn) }
#nextBtn{ background:var(--next-btn) }
#homeBtn{ background:var(--home-btn) }

@media(min-width:720px){
  h1{ font-size:28px } .hint{ font-size:16px } .fruit-name{ font-size:28px } .fruit-roman{ font-size:18px }
  #rollBtn{ font-size:16px } .play-audio{ font-size:14px } .bottom button{ font-size:14px }
}
</style>
</head>
<body>
<header>
  <h1>æœå­éª°ä»”éŠæˆ²-ç¬¬1å›</h1>
  <div class="hint">ğŸ“± å»ºè­°ç›´å¼è§€çœ‹æ•ˆæœæœ€ä½³</div>
</header>

<main>
  <div class="cube-wrap">
    <div class="cube-stage" id="stage">
      <div id="cube" class="cube" aria-hidden="false" role="img" aria-label="æœå­éª°å­" style="transform: rotateX(0deg) rotateY(0deg);">
        <div class="face front"><img src="game9_assets/fruit1.png" alt="æª¨ä»”"></div>
        <div class="face back"><img src="game9_assets/fruit2.png" alt="æŸ‘ä»”"></div>
        <div class="face right"><img src="game9_assets/fruit3.png" alt="å¼“è•‰"></div>
        <div class="face left"><img src="game9_assets/fruit4.png" alt="æ—èä»”"></div>
        <div class="face top"><img src="game9_assets/fruit5.png" alt="ç‹æ¢¨"></div>
        <div class="face bottom"><img src="game9_assets/fruit6.png" alt="æ™‚è¨ˆæœ"></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <button id="rollBtn">æ’šéª°ä»” ğŸ²</button>
  </div>

  <div id="result">
    <div class="fruit-name" id="fruitName">&nbsp;</div>
    <div class="fruit-roman" id="fruitRoman">&nbsp;</div>
    <button id="playPron" class="play-audio" style="display:none">ğŸ”Š è½å°èªç™¼éŸ³</button>
  </div>
</main>

<div class="bottom">
  <button id="againBtn">é–£è€ä¸€æ“º</button>
  <button id="nextBtn">å¾Œä¸€å›</button>
  <button id="homeBtn">è½‰å»éŠæˆ²é ­é </button>
</div>

<!-- try several possible filenames; fallback synth ensures audible roll -->
<audio id="rollSound" preload="auto"></audio>
<audio id="dingSound" preload="auto"></audio>
<audio id="fruitSound" preload="auto"></audio>

<script>
/* ---------- data ---------- */
const fruits = [
  { name: "æª¨ä»”", roman: "suÄinn-Ã¡", img: "game9_assets/fruit1.png", audio: "https://sutian.moe.edu.tw/media/senn/mp3/imtong/subak/12/12189.mp3" },
  { name: "æŸ‘ä»”", roman: "kam-Ã¡",   img: "game9_assets/fruit2.png", audio: "https://sutian.moe.edu.tw/media/senn/mp3/imtong/subak/5/5084.mp3" },
  { name: "å¼“è•‰", roman: "king-tsio",img: "game9_assets/fruit3.png", audio: "https://sutian.moe.edu.tw/media/senn/mp3/imtong/subak/0/529.mp3" },
  { name: "æ—èä»”",roman: "nÃ¡-puaÌt-Ã¡",img:"game9_assets/fruit4.png", audio: "https://sutian.moe.edu.tw/media/senn/mp3/imtong/subak/4/4237.mp3" },
  { name: "ç‹æ¢¨", roman: "Ã´ng-lÃ¢i", img: "game9_assets/fruit5.png", audio: "https://sutian.moe.edu.tw/media/senn/mp3/imtong/subak/1/1260.mp3" },
  { name: "æ™‚è¨ˆæœ",roman: "sÃ®-kÃ¨-kÃ³",img: "game9_assets/fruit6.png", audio: "https://sutian.moe.edu.tw/media/senn/mp3/imtong/subak/14/14205.mp3" }
];

/* ---------- CORRECTED base rotations that make each face exactly front+upright ----------
   NOTE: right face (.face.right { rotateY(90deg) }) comes to front when cube rotated around Y by -90deg.
   So we set right -> y: -90, left -> y: 90 to match DOM order: front, back, right, left, top, bottom.
*/
const faceTarget = [
  { x: 0,   y: 0   },  // front  -> fruit1
  { x: 0,   y: 180 },  // back   -> fruit2
  { x: 0,   y: -90 },  // right  -> fruit3  <-- corrected (was previously +90 in some versions)
  { x: 0,   y: 90  },  // left   -> fruit4  <-- corrected
  { x: -90, y: 0   },  // top    -> fruit5
  { x: 90,  y: 0   }   // bottom -> fruit6
];

/* audio candidate filenames for roll and ding (try several common variants) */
const rollCandidates = [
  'game9_assets/Roll_the_dice.mp3',
  'game9_assets/Roll the dice.mp3',
  'game9_assets/RollTheDice.mp3',
  'game9_assets/Roll the Dice.mp3'
];
const dingCandidates = [
  'game9_assets/ding.mp3',
  'game9_assets/ding_sound.mp3',
  'game9_assets/ding-short.mp3'
];

/* ---------- DOM ---------- */
const cube = document.getElementById('cube');
const rollBtn = document.getElementById('rollBtn');
const fruitNameEl = document.getElementById('fruitName');
const fruitRomanEl = document.getElementById('fruitRoman');
const playPronBtn = document.getElementById('playPron');
const againBtn = document.getElementById('againBtn');
const nextBtn = document.getElementById('nextBtn');
const homeBtn = document.getElementById('homeBtn');
const rollSound = document.getElementById('rollSound');
const dingSound = document.getElementById('dingSound');
const fruitSound = document.getElementById('fruitSound');

let animating = false;
let lastBase = { x:0, y:0 }; // track current snapped base orientation

/* ---------- SEQUENCE (æ´—ç‰Œ) for fair distribution ---------- */
let sequence = [];
function refillSequence(){
  sequence = [0,1,2,3,4,5];
  // Fisher-Yates shuffle
  for(let i = sequence.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [sequence[i], sequence[j]] = [sequence[j], sequence[i]];
  }
  console.log('refilled sequence:', sequence);
}
refillSequence();

/* ---------- helper: set cube size responsive ---------- */
function updateCubeSize(){
  const maxW = Math.min(window.innerWidth * 0.86, 200);
  const maxH = Math.min(window.innerHeight * 0.46, 200);
  const size = Math.floor(Math.min(maxW, maxH));
  cube.style.setProperty('--cube-size', size + 'px');
}
window.addEventListener('resize', updateCubeSize);
window.addEventListener('orientationchange', updateCubeSize);
updateCubeSize();

/* ---------- audio helpers & fallback synth ---------- */
let audioCtx = null;
let synthNodes = null;

function startSynthRoll(){
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sawtooth';
    o.frequency.value = 40; // low rumble
    g.gain.value = 0.02;
    const noiseFilter = audioCtx.createBiquadFilter();
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.value = 600;
    o.connect(noiseFilter);
    noiseFilter.connect(g);
    g.connect(audioCtx.destination);
    o.start();
    synthNodes = { osc: o, gain: g, filter: noiseFilter };
  }catch(e){ console.warn('synth failed', e); synthNodes = null; }
}

function stopSynthRoll(){
  if(!synthNodes) return;
  try{
    const now = audioCtx.currentTime;
    synthNodes.gain.gain.setTargetAtTime(0, now, 0.02);
    setTimeout(()=> {
      try{ synthNodes.osc.stop(); synthNodes.osc.disconnect(); synthNodes.filter.disconnect(); synthNodes.gain.disconnect(); }catch(e){}
      synthNodes = null;
    }, 120);
  }catch(e){ synthNodes = null; }
}

/* try to play roll sound from candidate list; returns promise(boolean) */
async function tryPlayRollAudio(){
  rollSound.loop = true;
  rollSound.volume = 1;
  for(const src of rollCandidates){
    try{
      rollSound.src = src;
      rollSound.load();
      await rollSound.play();
      console.log('rollSound playing from', src);
      return true;
    }catch(e){
      console.warn('rollSound candidate failed:', src, e);
      // try next candidate
    }
  }
  // all candidates failed -> fallback to synth
  console.warn('all rollSound candidates failed, using synth fallback');
  startSynthRoll();
  return false;
}

/* try to set ding sound (non-loop) */
async function tryLoadDing(){
  for(const src of dingCandidates){
    try{
      dingSound.src = src;
      dingSound.load();
      // don't play now; just ensure it's set (will play later)
      console.log('dingSound set to', src);
      return;
    }catch(e){ console.warn('ding candidate failed', src, e); }
  }
  // no ding file: leave dingSound empty (we can use short synth beep later)
}

/* ---------- core roll logic (uses sequence for fairness) ---------- */
async function rollDice(){
  if(animating) return;
  animating = true;
  fruitNameEl.textContent = '';
  fruitRomanEl.textContent = '';
  playPronBtn.style.display = 'none';

  // ensure ding attempts loaded
  tryLoadDing();

  // try to play roll audio (if fails, synth started)
  try {
    await tryPlayRollAudio();
  } catch(e){ console.warn('tryPlayRollAudio error', e); }

  // pick next from sequence (refill if empty)
  if(sequence.length === 0) refillSequence();
  const chosen = sequence.pop();
  const target = faceTarget[chosen];
  console.log('chosen', chosen, fruits[chosen].name, 'target', target);

  // spins (full 360 multiples) for visual effect
  const spinRoundsX = 3 + Math.floor(Math.random() * 3); // 3..5
  const spinRoundsY = 3 + Math.floor(Math.random() * 3); // 3..5
  const largeX = spinRoundsX * 360 + target.x;
  const largeY = spinRoundsY * 360 + target.y;

  // animate from current snapped base to base + large spins
  cube.style.transition = 'transform 1800ms cubic-bezier(.19,.57,.3,.98)';
  const startX = lastBase.x;
  const startY = lastBase.y;
  cube.style.transform = `rotateX(${startX}deg) rotateY(${startY}deg)`;
  requestAnimationFrame(()=> {
    requestAnimationFrame(()=> {
      cube.style.transform = `rotateX(${startX + largeX}deg) rotateY(${startY + largeY}deg)`;
    });
  });

  const ANIM_MS = 1800;
  setTimeout(()=>{
    // stop roll audio (file or synth)
    try{
      if(!rollSound.paused){
        rollSound.loop = false;
        rollSound.pause();
        rollSound.currentTime = 0;
      }
    }catch(e){ console.warn('stop rollSound error', e); }
    stopSynthRoll();

    // play ding (if available), else quick synth beep
    if(dingSound.src){
      try{ dingSound.currentTime = 0; dingSound.play().catch(()=>{}); }catch(e){}
    }else{
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioCtx.resume();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = 880;
        g.gain.value = 0.0008;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{ g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02); setTimeout(()=>{ o.stop(); o.disconnect(); g.disconnect(); }, 80); }, 120);
      }catch(e){ console.warn('ding synth failed', e); }
    }

    // display matched text & load pronunciation
    const f = fruits[chosen];
    fruitNameEl.textContent = f.name;
    fruitRomanEl.textContent = f.roman;
    playPronBtn.style.display = 'inline-block';
    fruitSound.src = f.audio;
    fruitSound.load();

    // SNAP to exact base orientation (no transition) to guarantee upright / not flipped
    cube.style.transition = 'none';
    cube.style.transform = `rotateX(${target.x}deg) rotateY(${target.y}deg)`;
    void cube.offsetHeight;
    cube.style.transition = 'transform 800ms cubic-bezier(.19,.57,.3,.98)';

    // update lastBase for next roll start
    lastBase = { x: target.x, y: target.y };

    animating = false;
    console.log('rolled ->', f.name, ' snapped to target', target);
  }, ANIM_MS + 60);
}

/* play pronunciation */
playPronBtn.addEventListener('click', ()=>{
  if(!fruitSound.src) return;
  try{
    fruitSound.currentTime = 0;
    fruitSound.play().catch(e => console.warn('fruitSound play blocked', e));
  }catch(e){ console.warn(e); }
});

/* wire UI */
rollBtn.addEventListener('click', rollDice);
againBtn.addEventListener('click', ()=>{ rollDice(); });
nextBtn.addEventListener('click', ()=>{ window.location.href='game9_round2.html'; });
homeBtn.addEventListener('click', ()=>{ window.location.href='index.html'; });

/* safety: if images missing show console warning */
document.querySelectorAll('.face img').forEach(img=>{
  img.onerror = ()=>{ console.warn('Missing image:', img.src); img.style.opacity = 0.2; };
});

/* initial: attempt to preload roll/ding candidates (non-blocking) */
(function preloadAudioCandidates(){
  (async ()=>{
    for(const s of dingCandidates){
      try{ dingSound.src = s; dingSound.load(); console.log('preload ding candidate', s); break; }catch(e){ continue; }
    }
    for(const s of rollCandidates){
      try{ rollSound.src = s; rollSound.load(); console.log('preload roll candidate', s); break; }catch(e){ continue; }
    }
  })();
})();
</script>
</body>
</html>
